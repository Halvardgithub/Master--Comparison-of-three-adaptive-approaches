---
title: "WinBUGS model"
author: "Halvard"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(R2WinBUGS)

#remotes::install_github("fisabio/pbugs")
library(pbugs)

library(readr)
library(ggplot2)

library(sf)
library(spdep)
library(dplyr)
```

### Loading data
Load the data and spatial structures.
```{r}
ExpectedCases <- readRDS("ExpectedCasesMiguel.rds")
ObservedCases <- readRDS("ObservedCases.rds")
PopulationData <- readRDS("PopulationData.rds")
nDiseasesTot <- as.numeric(ncol(ObservedCases)) #the number of causes

shp_prov <- st_read("Data/Provinces/Provincias_ETRS89_30N.shp")
colnames(shp_prov) <- c("Index", "ProvName", "ProvName1", "CCAA_Index", "CCAA_Name", "geometry")
CCAA_to_remove <- c("Illes Balears", "Canarias", "Ceuta", "Melilla")
shp_prov <- filter(shp_prov, !CCAA_Name %in% CCAA_to_remove)
carto <- shp_prov

#Spatial structure
carto.nb <- poly2nb(carto) # Neighbours list of each geographic unit with class nb
carto.wb <- nb2WB(carto.nb) # List with the adjacency vector (carto.wb$adj) and
# the number of neighbors of each geographic unit (carto.wb$num) to use in WinBUGS
index <- c(1, cumsum(carto.wb$num)) # Vector to identify the positions of the neighbors
# of each geographic unit in the conditional distributions of spatial effects

#Randomize disease from 1-86, numbers are 10, 20 and 50
get_causes <- function(n){ #nDiseasesTot is defined further up
  set.seed(12345)
  subset <- sample(1:nDiseasesTot, n, replace = FALSE) #there is a total of 102 diseases
  return(sort(subset))
}

causes10 <- get_causes(10) #the indexes corresponding to 10 random diseases, if n=20 we keep the first 10 and get 10 new ones
causes20 <- get_causes(20)
causes50 <- get_causes(50)
causes86 <- get_causes(86)
```
Note that "Tumor Maligno del cruello del utero" in exp10 are all zero, so should be removed from the original datasets."Tumores in suto" is also extremely low. "XV.Embarazo, parto y puerpeira" as well. There is also some for homocides and maybe also accidents and such. 

### Implement the multivariate adaptive model with WinBUGS

Generally, i indicates a spatial region/province and j represents a disease or cause of death. 
```{r}
# Multivariate adaptive BYM model, WinBUGS code, with iid effect theta
AdaptiveBYM_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    prec.phi[1, j] <- pow(sd.phi[j], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, j] <- pow(sd.phi[j], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    mean.phi[1, j] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # %_% 0.001 ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```

The model without the spatial iid effect theta.
```{r}
# Multivariate adaptive BYM model, WinBUGS code, without iid effect theta
AdaptiveBYM_model_NOiid <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    prec.phi[1, j] <- pow(sd.phi[j], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, j] <- pow(sd.phi[j], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    mean.phi[1, j] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # %_% 0.001 ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```
I removed sd.theta and theta, so they should also not be passed to the model!


# Run the model
Now we are ready to run the model in WinBUGS. We choose the mortality causes, either 10, 20 or 50 causes and run the multivariate model.

```{r, eval=FALSE}
#For the model with iid theta, the spatial random effect
# # Initial values
# initials <- function() {
#   list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
#        sd.theta = runif(data$Ndiseases, 0, 1), 
#        phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
#               ncol = data$Ndiseases),
#        theta = matrix(rnorm(data$Nareas * data$Ndiseases),
#               nrow = data$Nareas, ncol = data$Ndiseases), 
#        c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
# }
# # Variables to retrieve
# param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")

runtime_ABYM <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
# Initial values
initials <- function(){
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases), 
       c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
}
# Variables to retrieve
param <- c("mu", "lambda", "sd.phi", "phi","SMR", "c", "sd.c", "tau")
# Calls to WinBUGS
results.AdaptiveBYM.10 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.20 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.50 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.86 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model_NOiid,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[4] <- t1 - t0

# Comparing runtimes and writing to file

runtime_ABYM

result_list_ABYM <- list(results.AdaptiveBYM.10, results.AdaptiveBYM.20, 
                         results.AdaptiveBYM.50, results.AdaptiveBYM.86, runtime_ABYM)
saveRDS(result_list_ABYM, file = "Results//result_list_ABYM.rds")
```

Runtimes for Miguels model in WinBUGS(cirka): 
10 casues takes 10 min
20 causes takes 20 min
50 causes takes 1h 30 min
86 causes takes 5h 30 min


```{r}
res_list_ABYM <- readRDS("Results//Results_withScaling_and_without_iidTheta//result_list_ABYM.rds")

res_list_ABYM[[5]]

#res_list_ABYM <- readRDS("Results//result_list_longer_chains.rds")

ss_provinces = read_sf("Data/Provinces/Provincias_ETRS89_30N.shp")

ss_ar = read_sf("Data/AutonomousRegions/Comunidades_Autonomas_ETRS89_30N.shp")

ggplot() + geom_sf(data = ss_provinces) + geom_sf(data = ss_ar)

# we only work with mainland Spain, remove the islands

out = c("Islas Baleares", "Las Palmas", "Santa Cruz de Tenerife", "Ceuta", "Melilla")

out2 = c("Canarias", "Islas Baleares", "Ceuta", "Melilla")

ss_provinces = ss_provinces |> filter(!(Texto %in% out))

ss_ar = ss_ar %>% filter(!(Texto %in% out2))

ss_provinces$color10 <- res_list_ABYM[[1]]$mean$c
ss_provinces$color20 <- res_list_ABYM[[2]]$mean$c
ss_provinces$color50 <- res_list_ABYM[[3]]$mean$c
ss_provinces$color86 <- res_list_ABYM[[4]]$mean$c

#can change the fill=NA to add colours
ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=10 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=20 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=50 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for all n=86 causes")

```

Assessing convergence and other properties of the MCMC simulations.
```{r}
#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list_ABYM[[1]]$summary[, "Rhat"])
range(res_list_ABYM[[2]]$summary[, "Rhat"])
range(res_list_ABYM[[3]]$summary[, "Rhat"])
range(res_list_ABYM[[4]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list_ABYM[[1]]$summary[, "Rhat"] > 1.1)
which(res_list_ABYM[[2]]$summary[, "Rhat"] > 1.1)
which(res_list_ABYM[[3]]$summary[, "Rhat"] > 1.1)
which(res_list_ABYM[[4]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list_ABYM[[1]]$summary["tau",]
res_list_ABYM[[2]]$summary["tau",]
res_list_ABYM[[3]]$summary["tau",]
res_list_ABYM[[4]]$summary["tau",]

#Correlation between the weights c for differing number of causes n
cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```



# The more flexible adaptive multivariate model by Riddervoll/Jo
This model instead uses an adaptive ICAR with an individual precision tau for each pair of neighbors i ~ j. Thus, the number of precision parameters equals the number of edges in the graph, or |E| compared to the number of regions in the model above by Miguel. All the precision have the same gamma prior, in their article with scaled data they used Gamma(1.0, 1.2) with a shape and scale parametrization.

```{r}
#before the WinBUGS code
my_list <- vector("list", 47)
for (i in 1:47) {
  my_list[i] <- rep(0, carto.wb$num[i])  # Initialize each element as an empty list
}

count_num <- 1

#for i = 1
for (j in (index[1]):index[2]){
  my_list[[1]] <- append(my_list[[1]], count_num)
  my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
  count_num <- count_num + 1
}

# for i > 1
for (i in 2:47){ #the number of regions
  for (j in (index[i]+1):index[i+1]){
    if (carto.wb$adj[j]>i){
      my_list[[i]] <- append(my_list[[i]], count_num)
      my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
      count_num <- count_num + 1
    }
  }
} 

my_list <- unlist(my_list, use.names = FALSE)

my_list <- as.integer(my_list[which(my_list != 0)])
```



```{r}
# Multivariate adaptive BYM model, WinBUGS code and iid spatial effect theta
NSRW1_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  
  for (i in 1:n.adj) {
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }

  for (j in 1:Ndiseases) {
     prec.phi[1, j] <- pow(sd.phi[j], -2) * sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, j] <- pow(sd.phi[j], -2) * sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting too many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
      mean.phi[1, j] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  ## Prior distributions for Tau2 and its hyperparameters
  for (t in 1:(n.adj/2)){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, )
  }
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```

The model without spatial iid effect theta to focus on the spatially structured effect phi.

```{r}
# Multivariate adaptive BYM model, WinBUGS code without spatial iid effect theta
NSRW1_model_NOiid <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
    }
  }
  
  for (i in 1:n.adj) {
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }

  for (j in 1:Ndiseases) {
     prec.phi[1, j] <- pow(sd.phi[j], -2) * sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, j] <- pow(sd.phi[j], -2) * sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting too many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
      mean.phi[1, j] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  ## Prior distributions for Tau2 and its hyperparameters
  for (t in 1:(n.adj/2)){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, )
  }
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```


```{r, eval=FALSE}
runtime_NSRW1 <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index, 
             tau.list = my_list)
#For the model with iid spatial effect theta
# # Initial values
# initials_NSRW1 <- function() {
#   list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
#        sd.theta = runif(data$Ndiseases, 0, 1), 
#        phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
#               ncol = data$Ndiseases),
#        theta = matrix(rnorm(data$Nareas * data$Ndiseases),
#               nrow = data$Nareas, ncol = data$Ndiseases), 
#        Tau2 = runif(data$n.adj/2, 0.5, 3))
# }
# 
# # Variables to retrieve
# param_NSRW1 <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "Tau2", "sd.alpha", "alpha")

# Initial values
initials_NSRW1 <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1),
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas,
              ncol = data$Ndiseases),
       Tau2 = runif(data$n.adj/2, 0.5, 3))
}

# Variables to retrieve
param_NSRW1 <- c("mu", "lambda", "sd.phi", "phi","SMR", "Tau2", "sd.alpha", "alpha")

# Calls to WinBUGS
results.NSRW1.10 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.20 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.50 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.86 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model_NOiid,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[4] <- t1 - t0


# Comparing runtimes

runtime_NSRW1

result_list_NSRW1 <- list(results.NSRW1.10, results.NSRW1.20, results.NSRW1.50, 
                    results.NSRW1.86, runtime_NSRW1)
saveRDS(result_list_NSRW1, file = "Results//result_list_NSRW1.rds")
```

Assessing convergence and other properties of the MCMC simulations.

```{r}
res_list_NSRW1 <- readRDS("Results//Results_withScaling_and_without_iidTheta//result_list_NSRW1.rds")

#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list_NSRW1[[1]]$summary[, "Rhat"])
range(res_list_NSRW1[[2]]$summary[, "Rhat"])
range(res_list_NSRW1[[3]]$summary[, "Rhat"])
range(res_list_NSRW1[[4]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list_NSRW1[[1]]$summary[, "Rhat"] > 1.1)
which(res_list_NSRW1[[2]]$summary[, "Rhat"] > 1.1)
which(res_list_NSRW1[[3]]$summary[, "Rhat"] > 1.1)
which(res_list_NSRW1[[4]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list_NSRW1[[1]]$summary["alpha",]
res_list_NSRW1[[2]]$summary["alpha",]
res_list_NSRW1[[3]]$summary["alpha",]
res_list_NSRW1[[4]]$summary["alpha",]

res_list_NSRW1[[1]]$mean$Tau2
res_list_NSRW1[[4]]$mean$Tau2

#Correlation between the weights c for differing number of causes n
#cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```

#Plots and visualization of results

Plots and visualization of the results. The plot with colored provinces represents the precision in each region, which equals the sum of the precision of the connected edges. Additionally, the plot with colored edges represents the precision of each edge, not sure how to make this yet. Ideally the plot has different colors for the edges, and the autonomous region borders are also thicker, so they are visible in the figure. Maybe they are lower precision mostly??


#Edgeplots for the WinBUGS models by Miguel and Jo
Lets make the edgeplots for each number n of causes for each of the two models and summarise it in a 4X2 figure.

## Edgeplots for the temporal NSRW1 model

The indexing actually works out nicely. So, the way I constructed my_list aligns with how the edge_list gets the neighbors from the shape file (from chatGPT). 

```{r}
#Plots for the precision of each edge
library(sf)
library(spdep)
library(ggplot2)
library(dplyr)

# Compute centroids
centroids <- st_centroid(ss_provinces)

# Create an adjacency list
nb <- poly2nb(ss_provinces)

# Create an empty list to store edges and metadata
edge_list <- list()
region_from <- c()
region_to <- c()

# Loop through each region to create edges and store region names/IDs
for (i in seq_along(nb)) {
  neighbors <- nb[[i]]
  if (length(neighbors) == 0) next
  
  for (j in neighbors) {
    # Store the line geometry
    edge_list <- append(edge_list, 
                        list(st_linestring(rbind(st_coordinates(centroids[i, ]), 
                                                 st_coordinates(centroids[j, ])))))
    
    # Store region names or IDs
    region_from <- c(region_from, i)  # Replace 'NAME' with the correct column name
    region_to <- c(region_to, j)
  }
}

# Convert to an sf object
edges_sf <- st_sf(geometry = st_sfc(edge_list, crs = st_crs(ss_provinces)), 
                  from = region_from, to = region_to)

#Add the precisions/linewidth
# tau_list is the 111 precisions for the edges
example_tau_list <- c(rep(1, 50), rep(3, 61))
#edge_weight <- rep(0, nrow(edges_sf))
#edge_weight <- tau_list[my_list] #so 222 edge weights, two equal weights for each edge

#edges_sf$edge_value <- edge_weight
edges_sf$example_edge_value <- example_tau_list[my_list]
edges_sf$edge_value_NSRW1_10 <- res_list_NSRW1[[1]]$mean$Tau2[my_list]*
      mean(1/(res_list_NSRW1[[1]]$mean$sd.phi)^2)
edges_sf$edge_value_NSRW1_20 <- res_list_NSRW1[[2]]$mean$Tau2[my_list]*
      mean(1/(res_list_NSRW1[[2]]$mean$sd.phi)^2)
edges_sf$edge_value_NSRW1_50 <- res_list_NSRW1[[3]]$mean$Tau2[my_list]*
      mean(1/(res_list_NSRW1[[3]]$mean$sd.phi)^2)
edges_sf$edge_value_NSRW1_86 <- res_list_NSRW1[[4]]$mean$Tau2[my_list]*
      mean(1/(res_list_NSRW1[[4]]$mean$sd.phi)^2)

# Example plot with varying edge widths
ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 3) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = example_edge_value), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  # Adjust thickness range
  ggtitle("Example plot for edges with different precisions") +
  theme_minimal()

# 10 causes
edgeplot_NSRW1_10 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_NSRW1_10), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank())  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 20 causes
edgeplot_NSRW1_20 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_NSRW1_20), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank())  +
   guides(linewidth = guide_legend(title = "Width mapping"))

# 50 causes
edgeplot_NSRW1_50 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_NSRW1_50), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank()) +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 86 causes
edgeplot_NSRW1_86 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_NSRW1_86), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(x = "EW-ICAR") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
```


## Edge plots for Miguels adaptive BYM and for Jo's NSRW1 model
For this model the outputs are the weights c, one for each region. The precision for a given edge between neighbors is then the product of the c's in the two provinces. We get the following relation between $\tau_{ij}$ and $c_i$ and $c_j$:
$$
\tau_{ij} = \sqrt{c_i*c_j}
$$
Additionally, it is important that the calculated tau's match with the positions from the NSRW1 model above. Now lets calculate the tau's.
```{r}
nAreas <- length(carto.wb$num)
nEdges <- length(carto.wb$adj)/2

#the scaling tau averaged over all the causes of death for each n
# mean(1/(res_list_ABYM[[1]]$mean$sd.phi)^2)
# mean(1/(res_list_ABYM[[2]]$mean$sd.phi)^2)
# mean(1/(res_list_ABYM[[3]]$mean$sd.phi)^2)
# mean(1/(res_list_ABYM[[4]]$mean$sd.phi)^2)

# 10 causes
count_num <- 1
tau_list_ABYM_10 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_ABYM_10[count_num] <- sqrt(res_list_ABYM[[1]]$mean$c[i]*
              res_list_ABYM[[1]]$mean$c[j]) * mean(1/(res_list_ABYM[[1]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 20 causes
count_num <- 1
tau_list_ABYM_20 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_ABYM_20[count_num] <- sqrt(res_list_ABYM[[2]]$mean$c[i]*
            res_list_ABYM[[2]]$mean$c[j])*mean(1/(res_list_ABYM[[2]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 50 causes
count_num <- 1
tau_list_ABYM_50 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_ABYM_50[count_num] <- sqrt(res_list_ABYM[[3]]$mean$c[i]*
              res_list_ABYM[[3]]$mean$c[j])*mean(1/(res_list_ABYM[[3]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 86 causes
count_num <- 1
tau_list_ABYM_86 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_ABYM_86[count_num] <- sqrt(res_list_ABYM[[4]]$mean$c[i]*
            res_list_ABYM[[4]]$mean$c[j])*mean(1/(res_list_ABYM[[4]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

edges_sf$edge_value_ABYM_10 <- tau_list_ABYM_10
edges_sf$edge_value_ABYM_20 <- tau_list_ABYM_20
edges_sf$edge_value_ABYM_50 <- tau_list_ABYM_50
edges_sf$edge_value_ABYM_86 <- tau_list_ABYM_86

#Making the plots

# 10 causes
edgeplot_ABYM_10 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_ABYM_10), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(y = "n = 10") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 20 causes
edgeplot_ABYM_20 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_ABYM_20), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) + 
  labs(y = "n = 20") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))

# 50 causes
edgeplot_ABYM_50 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_ABYM_50), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) + 
  labs(y = "n = 50") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 86 causes
edgeplot_ABYM_86 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_ABYM_86), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(x = "RW-ICAR", y = "n = 86") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(linewidth = guide_legend(title = "Width mapping"))

```

## Plot them all together in one figure

Now lets collect all the plots in an edgeplot figure:
```{r}
library(ggpubr)

edgeplots <- list(edgeplot_ABYM_10, edgeplot_NSRW1_10, edgeplot_ABYM_20, edgeplot_NSRW1_20,
               edgeplot_ABYM_50, edgeplot_NSRW1_50, edgeplot_ABYM_86, edgeplot_NSRW1_86)

final_edgeplot <- ggarrange(plotlist = edgeplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//edgeFigure.png", plot = final_edgeplot, height = 24, width = 21,  units = "cm",  dpi = 300)
```


# Plots of the total precision for each regions for the WinBUGS models
Plot of the total precision, i.e. the sum of the precision of the connected edges for all regions. Lets start with making the plots for the temporal NSRW1 by Jo and Riddervold.

## Total precision per region for temporal NSRW1

As this model calculates the precision tau for each edge, the precision for each region is simply the sum of the connecting edges. Lets first compute these sums before making the plots for each number of causes $n$.

```{r}
#Plot for the total precision of each region

# 10 causes
precision_list10 <- rep(0, nAreas) 
tau_list <- res_list_NSRW1[[1]]$mean$Tau2*mean(1/(res_list_NSRW1[[1]]$mean$sd.phi)^2)

precision_list10[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list10[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 20 causes
precision_list20 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_NSRW1[[2]]$mean$Tau2*mean(1/(res_list_NSRW1[[2]]$mean$sd.phi)^2)

precision_list20[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list20[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 50 causes
precision_list50 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_NSRW1[[3]]$mean$Tau2*mean(1/(res_list_NSRW1[[3]]$mean$sd.phi)^2)

precision_list50[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list50[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 86 causes
precision_list86 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_NSRW1[[4]]$mean$Tau2*mean(1/(res_list_NSRW1[[4]]$mean$sd.phi)^2)

precision_list86[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list86[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

ss_provinces$color10_NSRW1 <- precision_list10
ss_provinces$color20_NSRW1 <- precision_list20
ss_provinces$color50_NSRW1 <- precision_list50
ss_provinces$color86_NSRW1 <- precision_list86

#can change the fill=NA to add colours
precplot_NSRW1_10 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_NSRW1_20 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_NSRW1_50 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_NSRW1_86 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4)  +
  labs(x = "EW-ICAR") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))
```

## Precision plots for the adaptive BYM by Miguel


```{r}
#Plot for the total precision of each region

# 10 causes
precision_list10 <- rep(0, nAreas) 

precision_list10[1] <- sum(tau_list_ABYM_10[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list10[i] <- sum(tau_list_ABYM_10[(index[i] + 1):index[i + 1]])
}

# 20 causes
precision_list20 <- rep(0, nAreas)

precision_list20[1] <- sum(tau_list_ABYM_20[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list20[i] <- sum(tau_list_ABYM_20[(index[i] + 1):index[i + 1]])
}

# 50 causes
precision_list50 <- rep(0, nAreas) 

precision_list50[1] <- sum(tau_list_ABYM_50[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list50[i] <- sum(tau_list_ABYM_50[(index[i] + 1):index[i + 1]])
}

# 86 causes
precision_list86 <- rep(0, nAreas) 

precision_list86[1] <- sum(tau_list_ABYM_86[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list86[i] <- sum(tau_list_ABYM_86[(index[i] + 1):index[i + 1]])
}

ss_provinces$color10_ABYM <- precision_list10
ss_provinces$color20_ABYM <- precision_list20
ss_provinces$color50_ABYM <- precision_list50
ss_provinces$color86_ABYM <- precision_list86

#can change the fill=NA to add colours
precplot_ABYM_10 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10_ABYM), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 10") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_ABYM_20 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20_ABYM), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 20") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_ABYM_50 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50_ABYM), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 50") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_ABYM_86 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86_ABYM), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(x = "RW-ICAR",y = "n = 86") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))
```

## Collecting the 8 precision plots in the same figure

```{r}
precplots <- list(precplot_ABYM_10, precplot_NSRW1_10, precplot_ABYM_20, precplot_NSRW1_20,
               precplot_ABYM_50, precplot_NSRW1_50, precplot_ABYM_86, precplot_NSRW1_86)

final_precplot <- ggarrange(plotlist = precplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//precFigure.png", plot = final_precplot, height = 24, width = 21,  units = "cm",  dpi = 300)
```


# Scatterplots for comparing the two WinBUGS models and an Anova comparison
The scatterplots are again 8 plots, 4 for precision in each region and 4 for the precision in edges. They are both for each number of causes n = 10, 20, 50, 86. For edges, the edges within an autonomous region should be one color while edges between autonomous regions should be another. This is also the split for the anova test. Lets start be dividing the precisions for the edges in the two groups.

```{r}
# So we have a vector of 111, or 222, precisions for the edges
#edges_sf$edge_value_NSRW1_10 #format for NSRW1
#edges_sf$edge_value_ABYM_10 #format for ABYM
#index2 <- index
#index2[1] <- 0 #so the first node works as the rest, i.e. from index[t]+1:index[t+1] 

#Lets make a vector indicating the groups by 0 or 1
inter_region_edges <- rep(0, nEdges*2) #nEdges is 111
sum(inter_region_edges)
for (i in 1:(nEdges*2)){
  reg1 <- edges_sf$from[i] #index of the from region
  reg2 <- edges_sf$to[i]   #index of the to region
  if (carto$CCAA_Index[reg1] == carto$CCAA_Index[reg2]){
    inter_region_edges[i] <- 1
  }
}

between_region_edges <- 1 - inter_region_edges
edges_sf$inter_region_edges <- inter_region_edges
edges_sf$between_region_edges <- between_region_edges
```

## Scatterplots for the edges for the WinBUGS models
Lets now make the four plots for the different number of causes n.

```{r}
# 10 causes
cor_edges_10 <- cor(edges_sf$edge_value_ABYM_10, edges_sf$edge_value_NSRW1_10)

SCplot_edges_10 <- ggplot(edges_sf, aes(x = edge_value_ABYM_10, y = edge_value_NSRW1_10, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_10, 3), "(n = 10)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 20 causes
cor_edges_20 <- cor(edges_sf$edge_value_ABYM_20, edges_sf$edge_value_NSRW1_20)

SCplot_edges_20 <- ggplot(edges_sf, aes(x = edge_value_ABYM_20, y = edge_value_NSRW1_20, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_20, 3), "(n = 20)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 50 causes
cor_edges_50 <- cor(edges_sf$edge_value_ABYM_50, edges_sf$edge_value_NSRW1_50)

SCplot_edges_50 <- ggplot(edges_sf, aes(x = edge_value_ABYM_50, y = edge_value_NSRW1_50, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_50, 3), "(n = 50)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 86 causes
cor_edges_86 <- cor(edges_sf$edge_value_ABYM_86, edges_sf$edge_value_NSRW1_86)

SCplot_edges_86 <- ggplot(edges_sf, aes(x = edge_value_ABYM_86, y = edge_value_NSRW1_86, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_86, 3), "(n = 86)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

```
For the above plots, red correspond to edges between different autonomous regions while blue are edges inside the same autonomous region.

## Scatter plots for total precision in each region

```{r}
# 10 causes
cor_prec_10 <- cor(ss_provinces$color10_ABYM, ss_provinces$color10_NSRW1)

SCplot_prec_10 <- ggplot(ss_provinces, aes(x = color10_ABYM, y = color10_NSRW1)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_prec_10, 3), "(n = 10)"))

# 20 causes
cor_prec_20 <- cor(ss_provinces$color20_ABYM, ss_provinces$color20_NSRW1)

SCplot_prec_20 <- ggplot(ss_provinces, aes(x = color20_ABYM, y = color20_NSRW1)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_20, 3), "(n = 20)"))

# 50 causes
cor_prec_50 <- cor(ss_provinces$color50_ABYM, ss_provinces$color50_NSRW1)

SCplot_prec_50 <- ggplot(ss_provinces, aes(x = color50_ABYM, y = color50_NSRW1)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_50, 3), "(n = 50)"))

# 86 causes
cor_prec_86 <- cor(ss_provinces$color86_ABYM, ss_provinces$color86_NSRW1)

SCplot_prec_86 <- ggplot(ss_provinces, aes(x = color86_ABYM, y = color86_NSRW1)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_86, 3), "(n = 86)"))
```

## Collecting the 8 scatterplots in the same figure

```{r}
scatterplots <- list(SCplot_edges_10, SCplot_prec_10, SCplot_edges_20, SCplot_prec_20,
                     SCplot_edges_50, SCplot_prec_50, SCplot_edges_86, SCplot_prec_86)

final_scatterplot <- ggarrange(plotlist = scatterplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//scatterFigure.png", plot = final_scatterplot, height = 24, width = 21,  units = "cm",  dpi = 300)

#save the edges_sf for use in the CV
#saveRDS(edges_sf, file = "Edges_df//Edges_W_scaling_WO_theta")
```


#Anova test for edges for differing number of causes n

```{r}
library(ggpubr)

anova_NSRW1_10 <- summary(aov(edges_sf$edge_value_NSRW1_10 ~ edges_sf$between_region_edges))
anova_NSRW1_20 <- summary(aov(edges_sf$edge_value_NSRW1_20 ~ edges_sf$between_region_edges))
anova_NSRW1_50 <- summary(aov(edges_sf$edge_value_NSRW1_50 ~ edges_sf$between_region_edges))
anova_NSRW1_86 <- summary(aov(edges_sf$edge_value_NSRW1_86 ~ edges_sf$between_region_edges))

anova_ABYM_10 <- summary(aov(edges_sf$edge_value_ABYM_10 ~ edges_sf$between_region_edges))
anova_ABYM_20 <- summary(aov(edges_sf$edge_value_ABYM_20 ~ edges_sf$between_region_edges))
anova_ABYM_50 <- summary(aov(edges_sf$edge_value_ABYM_50 ~ edges_sf$between_region_edges))
anova_ABYM_86 <- summary(aov(edges_sf$edge_value_ABYM_86 ~ edges_sf$between_region_edges))

anova_result <- c(anova_NSRW1_10[[1]][1, "Pr(>F)"], anova_NSRW1_20[[1]][1, "Pr(>F)"], 
                  anova_NSRW1_50[[1]][1, "Pr(>F)"], anova_NSRW1_86[[1]][1, "Pr(>F)"],
                  anova_ABYM_10[[1]][1, "Pr(>F)"], anova_ABYM_20[[1]][1, "Pr(>F)"],
                  anova_ABYM_50[[1]][1, "Pr(>F)"], anova_ABYM_86[[1]][1, "Pr(>F)"])

anova_result <- round(anova_result,  4)

anova_df <- data.frame(Adaptive_BYM = anova_result[5:8],
                       NSRW1 = anova_result[1:4])

row.names(anova_df) <- c("n=10", "n=20", "n=50", "n=86")
colnames(anova_df) <- c("Adaptive BYM", "Temporal NSRW1")

anova_edge_table <- ggtexttable(anova_df, theme = ttheme("mOrange"))

#ggsave("Plots//anovaFigure.png", plot = anova_edge_table, height = 12, width = 10,  units = "cm",  dpi = 300)
```


At the log scale for the precisions!

```{r}

anova_NSRW1_10 <- summary(aov(log(edges_sf$edge_value_NSRW1_10) ~ 
                                edges_sf$between_region_edges))
anova_NSRW1_20 <- summary(aov(log(edges_sf$edge_value_NSRW1_20) ~
                                edges_sf$between_region_edges))
anova_NSRW1_50 <- summary(aov(log(edges_sf$edge_value_NSRW1_50) ~
                                edges_sf$between_region_edges))
anova_NSRW1_86 <- summary(aov(log(edges_sf$edge_value_NSRW1_86) ~
                                edges_sf$between_region_edges))

anova_ABYM_10 <- summary(aov(log(edges_sf$edge_value_ABYM_10) ~
                               edges_sf$between_region_edges))
anova_ABYM_20 <- summary(aov(log(edges_sf$edge_value_ABYM_20) ~
                               edges_sf$between_region_edges))
anova_ABYM_50 <- summary(aov(log(edges_sf$edge_value_ABYM_50) ~
                               edges_sf$between_region_edges))
anova_ABYM_86 <- summary(aov(log(edges_sf$edge_value_ABYM_86) ~
                               edges_sf$between_region_edges))

anova_result_log <- c(anova_NSRW1_10[[1]][1, "Pr(>F)"], anova_NSRW1_20[[1]][1, "Pr(>F)"], 
                  anova_NSRW1_50[[1]][1, "Pr(>F)"], anova_NSRW1_86[[1]][1, "Pr(>F)"],
                  anova_ABYM_10[[1]][1, "Pr(>F)"], anova_ABYM_20[[1]][1, "Pr(>F)"],
                  anova_ABYM_50[[1]][1, "Pr(>F)"], anova_ABYM_86[[1]][1, "Pr(>F)"])

anova_result_log <- round(anova_result_log,  4)

anova_log_df <- data.frame(Adaptive_BYM = anova_result_log[5:8],
                       NSRW1 = anova_result_log[1:4])

row.names(anova_log_df) <- c("n=10", "n=20", "n=50", "n=86")
colnames(anova_log_df) <- c("Adaptive BYM", "Temporal NSRW1")

anova_log_edge_table <- ggtexttable(anova_log_df, theme = ttheme("mOrange"))

#ggsave("Plots//anovaLogFigure.png", plot = anova_log_edge_table, height = 12, width = 10,  units = "cm",  dpi = 300)
```




NB:
Should Autonomous regions and Provinces start with a capital letter? upper case
Was i supposed to run the models without an iid effect? At the moment I have a random effect for each province and disease I think.
Was the national mortality data subtracted by the provinces we removed when calculating the expected cases?
Need to choose appropriate names for the models, preferably consistent across text and figures. Any ideas? By author? NSRW1 or AICAR_E, AICAR_2, AICAR_I, EW-ICAR (edge weighted), RW-ICAR(region weighted), BW-ICAR (borders weighted)


## For leave one out cross-validation for the diseases and simulation of the weight matrix
```{r, eval=FALSE}
# Object where the results for each set of diseases will be
# saved
results.AdaptiveBYM <- list()
# Run multivariate adaptive BYM model for each set of
# diseases
causes <- causes10
for (i in 1:length(causes)) { #corresponds to the n in the line above
  # Selection of mortality causes
  causes.id <- causes[-c(i)]
  # Data
  data <- list(O = ObservedCases, E = ExpectedCases,
               Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
               n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
  # Initial values
  initials <- function() {
    list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
         sd.theta = runif(data$Ndiseases, 0, 1), 
         phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
                ncol = data$Ndiseases),
         theta = matrix(rnorm(data$Nareas * data$Ndiseases),
                nrow = data$Nareas, ncol = data$Ndiseases), 
         c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
  }
  # Variables to retrieve
  param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")
  # Calls to WinBUGS
  results.AdaptiveBYM[[i]] <- bugs(data = data, inits = initials,
                                    parameters.to.save = param, model = AdaptiveBYM_model,
                                    n.iter = 20, n.burnin = 10, n.chains = 3, DIC = F,
                                   debug = F)
}
# Save results
write_csv(results.AdaptiveBYM, file = "Results/results.AdaptiveBYM-Miguel.csv")


```





---
title: "WinBUGS model"
author: "Halvard"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(R2WinBUGS)

#remotes::install_github("fisabio/pbugs")
library(pbugs)

library(readr)
library(ggplot2)

library(sf)
library(spdep)
library(dplyr)
```

### Loading data
Load the data and spatial structures.
```{r}
ExpectedCases <- readRDS("ExpectedCasesMiguel.rds")
ObservedCases <- readRDS("ObservedCases.rds")
PopulationData <- readRDS("PopulationData.rds")
nDiseasesTot <- as.numeric(ncol(ObservedCases)) #the number of causes

shp_prov <- st_read("Data/Provinces/Provincias_ETRS89_30N.shp")
colnames(shp_prov) <- c("Index", "ProvName", "ProvName1", "CCAA_Index", "CCAA_Name", "geometry")
CCAA_to_remove <- c("Illes Balears", "Canarias", "Ceuta", "Melilla")
shp_prov <- filter(shp_prov, !CCAA_Name %in% CCAA_to_remove)
carto <- shp_prov

#Spatial structure
carto.nb <- poly2nb(carto) # Neighbours list of each geographic unit with class nb
carto.wb <- nb2WB(carto.nb) # List with the adjacency vector (carto.wb$adj) and
# the number of neighbors of each geographic unit (carto.wb$num) to use in WinBUGS
index <- c(1, cumsum(carto.wb$num)) # Vector to identify the positions of the neighbors
# of each geographic unit in the conditional distributions of spatial effects

#Randomize disease from 1-102 and do not need sex I think, numbers are 10, 20 and 50
get_causes <- function(n){ #nDiseasesTot is defined further up
  set.seed(12345)
  subset <- sample(1:nDiseasesTot, n, replace = FALSE) #there is a total of 102 diseases
  return(sort(subset))
}

causes10 <- get_causes(10) #the indexes corresponding to 10 random diseases, if n=20 we keep the first 10 and get 10 new ones
causes20 <- get_causes(20)
causes50 <- get_causes(50)
causes86 <- get_causes(86)
```
Note that "Tumor Maligno del cruello del utero" in exp10 are all zero, so should be removed from the original datasets."Tumores in suto" is also extremely low. "XV.Embarazo, parto y puerpeira" as well. There is also some for homocides and maybe also accidents and such. 

### Implement the multivariate adaptive model with WinBUGS

Generally, i indicates a spatial region/province and j represents a disease or cause of death. 
```{r}
# Multivariate adaptive BYM model, WinBUGS code
AdaptiveBYM_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    prec.phi[1, j] <- pow(sd.phi[j], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, j] <- pow(sd.phi[j], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    mean.phi[1, j] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # %_% 0.001 ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```


# Run the model
Now we are ready to run the model in WinBUGS. We choose the mortality causes, either 10, 20 or 50 causes and run the multivariate model.

```{r, eval=TRUE}
runtime_ABYM <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
# Initial values
initials <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       sd.theta = runif(data$Ndiseases, 0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases),
       theta = matrix(rnorm(data$Nareas * data$Ndiseases),
              nrow = data$Nareas, ncol = data$Ndiseases), 
       c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
}
# Variables to retrieve
param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")
# Calls to WinBUGS
results.AdaptiveBYM.10 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.20 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.50 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.86 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[4] <- t1 - t0

# Comparing runtimes and writing to file

runtime_ABYM

result_list_ABYM <- list(results.AdaptiveBYM.10, results.AdaptiveBYM.20, 
                         results.AdaptiveBYM.50, results.AdaptiveBYM.86)
saveRDS(result_list_ABYM, file = "Results//result_list_longer_chains.rds")
```

Runtimes for Miguels model in WinBUGS(cirka): 
10 casues takes 10 min
20 causes takes 20 min
50 causes takes 1h 30 min
86 causes takes 5h 30 min


```{r}
res_list <- readRDS("Results//result_list_longer_chains.rds")

ss_provinces = read_sf("Data/Provinces/Provincias_ETRS89_30N.shp")

ss_ar = read_sf("Data/AutonomousRegions/Comunidades_Autonomas_ETRS89_30N.shp")

ggplot() + geom_sf(data = ss_provinces) + geom_sf(data = ss_ar)

# we only work with mainland Spain, remove the islands

out = c("Islas Baleares", "Las Palmas", "Santa Cruz de Tenerife", "Ceuta", "Melilla")

out2 = c("Canarias", "Islas Baleares", "Ceuta", "Melilla")

ss_provinces = ss_provinces |> filter(!(Texto %in% out))

ss_ar = ss_ar %>% filter(!(Texto %in% out2))

ss_provinces$color10 <- res_list[[1]]$mean$c
ss_provinces$color20 <- res_list[[2]]$mean$c
ss_provinces$color50 <- res_list[[3]]$mean$c
ss_provinces$color86 <- res_list[[4]]$mean$c

#can change the fill=NA to add colours
ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=10 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=20 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=50 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for all n=86 causes")

```

Assessing convergence and other properties of the MCMC simulations.
```{r}
#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list[[1]]$summary[, "Rhat"])
range(res_list[[2]]$summary[, "Rhat"])
range(res_list[[3]]$summary[, "Rhat"])
range(res_list[[4]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list[[1]]$summary[, "Rhat"] > 1.1)
which(res_list[[2]]$summary[, "Rhat"] > 1.1)
which(res_list[[3]]$summary[, "Rhat"] > 1.1)
which(res_list[[4]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list[[1]]$summary["tau",]
res_list[[2]]$summary["tau",]
res_list[[3]]$summary["tau",]
res_list[[4]]$summary["tau",]

#Correlation between the weights c for differing number of causes n
cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```



Meeting at wednesday 9.15
and monday the following week at 11:00.


# The more flexible adaptive multivariate model by Riddervoll/Jo
This model instead uses an adaptive ICAR with an individual precision tau for each pair of neighbors i ~ j. Thus, the number of precision parameters equals the number of edges in the graph, or |E| compared to the number of regions in the model above by Miguel. All the precision have the same gamma prior, in their article with scaled data they used Gamma(1.0, 1.2) with a shape and scale parametrization.

```{r}
#before the WinBUGS code
my_list <- vector("list", 47)
for (i in 1:47) {
  my_list[i] <- rep(0, carto.wb$num[i])  # Initialize each element as an empty list
}

count_num <- 1

#for i = 1
for (j in (index[1]):index[2]){
  my_list[[1]] <- append(my_list[[1]], count_num)
  my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
  count_num <- count_num + 1
}

# for i > 1
for (i in 2:47){ #the number of regions
  for (j in (index[i]+1):index[i+1]){
    if (carto.wb$adj[j]>i){
      my_list[[i]] <- append(my_list[[i]], count_num)
      my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
      count_num <- count_num + 1
    }
  }
} 

my_list <- unlist(my_list, use.names = FALSE)

my_list <- as.integer(my_list[which(my_list != 0)])
```



```{r}
# Multivariate adaptive BYM model, WinBUGS code
NSRW1_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  
  for (i in 1:n.adj) {
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }

  for (j in 1:Ndiseases) {
     prec.phi[1, j] <- sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, j] <- sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting too many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
      mean.phi[1, j] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  ## Prior distributions for Tau2 and its hyperparameters
  for (t in 1:(n.adj/2)){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, )
  }
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```

```{r}
runtime_NSRW1 <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index, 
             tau.list = my_list)
# Initial values
initials_NSRW1 <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       sd.theta = runif(data$Ndiseases, 0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases),
       theta = matrix(rnorm(data$Nareas * data$Ndiseases),
              nrow = data$Nareas, ncol = data$Ndiseases), 
       Tau2 = runif(data$n.adj/2, 0.5, 3))
}

# Variables to retrieve
param_NSRW1 <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "Tau2", "sd.alpha", "alpha")
# Calls to WinBUGS
results.NSRW1.10 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.20 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.50 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.NSRW1.86 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[4] <- t1 - t0


# Comparing runtimes

runtime_NSRW1

result_list_NSRW1 <- list(results.NSRW1.10, results.NSRW1.20, results.NSRW1.50, 
                    results.NSRW1.86)
saveRDS(result_list_NSRW1, file = "Results//result_list_NSRW1.rds")
```

Assessing convergence and other properties of the MCMC simulations.

```{r}
res_list <- readRDS("Results//result_list_NSRW1.rds")

#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list[[1]]$summary[, "Rhat"])
range(res_list[[2]]$summary[, "Rhat"])
range(res_list[[3]]$summary[, "Rhat"])
range(res_list[[4]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list[[1]]$summary[, "Rhat"] > 1.1)
which(res_list[[2]]$summary[, "Rhat"] > 1.1)
which(res_list[[3]]$summary[, "Rhat"] > 1.1)
which(res_list[[4]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list[[1]]$summary["alpha",]
res_list[[2]]$summary["alpha",]
res_list[[3]]$summary["alpha",]
res_list[[4]]$summary["alpha",]

res_list[[1]]$mean$Tau2
res_list[[4]]$mean$Tau2

#Correlation between the weights c for differing number of causes n
#cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```

Plots and visualization of the results. The plot with colored provinces represents the precision in each region, which equals the sum of the precision of the connected edges. Additionally, the plot with colored edges represents the precision of each edge, not sure how to make this yet. Ideally the plot has different colors for the edges, and the autonomous region borders are also thicker, so they are visible in the figure. Maybe they are lower precision mostly??

```{r}
#Plot for the total precision of each region

# 10 causes
precision_list10 <- rep(0, length(carto.nb)) #maybe define nAreas at the start?
tau_list <- res_list[[1]]$mean$Tau2

precision_list10[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:length(carto.nb)){
  precision_list10[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 20 causes
precision_list20 <- rep(0, length(carto.nb)) #maybe define nAreas at the start?
tau_list <- res_list[[2]]$mean$Tau2

precision_list20[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:length(carto.nb)){
  precision_list20[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 50 causes
precision_list50 <- rep(0, length(carto.nb)) #maybe define nAreas at the start?
tau_list <- res_list[[3]]$mean$Tau2

precision_list50[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:length(carto.nb)){
  precision_list50[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 86 causes
precision_list86 <- rep(0, length(carto.nb)) #maybe define nAreas at the start?
tau_list <- res_list[[4]]$mean$Tau2

precision_list86[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:length(carto.nb)){
  precision_list86[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

ss_provinces$color10_NSRW1 <- precision_list10
ss_provinces$color20_NSRW1 <- precision_list20
ss_provinces$color50_NSRW1 <- precision_list50
ss_provinces$color86_NSRW1 <- precision_list86

#can change the fill=NA to add colours
ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Precision tau for n=10 causes with temporal NSRW1")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Precision tau for n=20 causes with temporal NSRW1")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Precision tau for n=50 causes with temporal NSRW1")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86_NSRW1), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Precision tau for n=86 causes with temporal NSRW1")



```


```{r}
#Plots for the precision of each edge

library(sf)
library(spdep)
library(ggplot2)
library(dplyr)

# Load your spatial data (example: provinces in Spain)
# ss_provinces <- st_read("your_shapefile.shp")

# Step 1: Compute centroids
centroids <- st_centroid(ss_provinces)

# Step 2: Determine neighboring regions
nb <- poly2nb(ss_provinces)  # Get adjacency list
edges <- do.call(rbind, lapply(1:length(nb), function(i) {
  neighbors <- nb[[i]]
  if (length(neighbors) == 0) return(NULL)
  
  # Create a data frame of line segments
  do.call(rbind, lapply(neighbors, function(j) {
    st_sfc(st_linestring(rbind(st_coordinates(centroids[i, ]), 
                               st_coordinates(centroids[j, ]))), 
           crs = st_crs(ss_provinces))
  }))
}))

# Convert edges into an sf object
edges_sf <- st_sf(geometry = st_sfc(edges, crs = st_crs(ss_provinces)))

# Step 3: Plot the edge graph
ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Plot regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Plot centroids
  geom_sf(data = edges_sf, color = "blue", linewidth = 0.5) +  # Plot edges
  theme_minimal()



```

The indexing actually works out nicely. So, the way I constructed my_list aligns with how the edge_list gets the neighbors from the shape file (from chatGPT). 

```{r}
library(sf)
library(spdep)
library(ggplot2)
library(dplyr)

# Compute centroids
centroids <- st_centroid(ss_provinces)

# Create an adjacency list
nb <- poly2nb(ss_provinces)

# Create an empty list to store edges and metadata
edge_list <- list()
region_from <- c()
region_to <- c()

# Loop through each region to create edges and store region names/IDs
for (i in seq_along(nb)) {
  neighbors <- nb[[i]]
  if (length(neighbors) == 0) next
  
  for (j in neighbors) {
    # Store the line geometry
    edge_list <- append(edge_list, 
                        list(st_linestring(rbind(st_coordinates(centroids[i, ]), 
                                                 st_coordinates(centroids[j, ])))))
    
    # Store region names or IDs
    region_from <- c(region_from, i)  # Replace 'NAME' with the correct column name
    region_to <- c(region_to, j)
  }
}

# Convert to an sf object
edges_sf <- st_sf(geometry = st_sfc(edge_list, crs = st_crs(ss_provinces)), 
                  from = region_from, to = region_to)

#Add the precisions/linewidth
# tau_list is the 111 precisions for the edges
edge_weight <- rep(0, nrow(edges_sf))
edge_weight <- tau_list[my_list]

edges_sf$edge_value <- edge_weight

# Plot with varying edge widths
ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value), color = "blue") +  # Variable-width edges
  scale_linewidth(range = c(0.2, 3)) +  # Adjust thickness range
  theme_minimal()

```



NB:
Was the national mortality data subtracted by the provinces we removed when calculating the expected cases?






## For leave one out cross-validation for the diseases and simulation of the weight matrix
```{r}
# Object where the results for each set of diseases will be
# saved
results.AdaptiveBYM <- list()
# Run multivariate adaptive BYM model for each set of
# diseases
causes <- causes10
for (i in 1:length(causes)) { #corresponds to the n in the line above
  # Selection of mortality causes
  causes.id <- causes[-c(i)]
  # Data
  data <- list(O = ObservedCases, E = ExpectedCases,
               Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
               n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
  # Initial values
  initials <- function() {
    list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
         sd.theta = runif(data$Ndiseases, 0, 1), 
         phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
                ncol = data$Ndiseases),
         theta = matrix(rnorm(data$Nareas * data$Ndiseases),
                nrow = data$Nareas, ncol = data$Ndiseases), 
         c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
  }
  # Variables to retrieve
  param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")
  # Calls to WinBUGS
  results.AdaptiveBYM[[i]] <- bugs(data = data, inits = initials,
                                    parameters.to.save = param, model = AdaptiveBYM_model,
                                    n.iter = 20, n.burnin = 10, n.chains = 3, DIC = F,
                                   debug = F)
}
# Save results
write_csv(results.AdaptiveBYM, file = "Results/results.AdaptiveBYM-Miguel.csv")


```





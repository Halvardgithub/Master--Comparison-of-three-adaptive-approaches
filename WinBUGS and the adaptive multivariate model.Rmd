---
title: "WinBUGS model"
author: "Halvard"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(R2WinBUGS)

#remotes::install_github("fisabio/pbugs") # installing pbugs from the github
library(pbugs)

library(readr)
library(ggplot2)

library(sf)
library(spdep)
library(dplyr)
```

### Loading data
Load the data and spatial structures.
```{r}
ExpectedCases <- readRDS("ExpectedCasesMiguel.rds")
ObservedCases <- readRDS("ObservedCases.rds")
PopulationData <- readRDS("PopulationData.rds")
nDiseasesTot <- as.numeric(ncol(ObservedCases)) #the number of causes

shp_prov <- st_read("Data/Provinces/Provincias_ETRS89_30N.shp")
colnames(shp_prov) <- c("Index", "ProvName", "ProvName1", "CCAA_Index", "CCAA_Name", "geometry")
CCAA_to_remove <- c("Illes Balears", "Canarias", "Ceuta", "Melilla")
shp_prov <- filter(shp_prov, !CCAA_Name %in% CCAA_to_remove)
carto <- shp_prov

#Spatial structure
carto.nb <- poly2nb(carto) # Neighbours list of each geographic unit with class nb
carto.wb <- nb2WB(carto.nb) # List with the adjacency vector (carto.wb$adj) and
# the number of neighbors of each geographic unit (carto.wb$num) to use in WinBUGS
index <- c(1, cumsum(carto.wb$num)) # Vector to identify the positions of the neighbors
# of each geographic unit in the conditional distributions of spatial effects

#Randomize disease from 1-86, numbers are 10, 20 and 50
get_causes <- function(n){ #nDiseasesTot is defined further up
  set.seed(12345)
  subset <- sample(1:nDiseasesTot, n, replace = FALSE) #there is a total of 102 diseases
  return(sort(subset))
}

causes10 <- get_causes(10) #the indexes corresponding to 10 random diseases, if n=20 we keep the first 10 and get 10 new ones
causes20 <- get_causes(20)
causes50 <- get_causes(50)
causes86 <- get_causes(86)
```
Note that "Tumor Maligno del cruello del utero" in exp10 are all zero, so should be removed from the original datasets."Tumores in suto" is also extremely low. "XV.Embarazo, parto y puerpeira" as well. There is also some for homocides and maybe also accidents and such. 

### Implement the multivariate adaptive model with WinBUGS

Generally, i indicates a spatial region/province and m represents a disease or cause of death. 
```{r}
# Multivariate region weighted model, WinBUGS code, with iid effect theta
RW_ICAR_withIID <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (m in 1:Ndiseases) {
      Y[i, m] ~ dpois(lambda[i, m])
      # Modeling of the mean for each region and disease
      log(lambda[i, m]) <- log(E[i, m]) + mu[m] + phi[i,m] + sd.theta[m] * theta[i, m]
      # Prior distribution for spatial effects
      phi[i, m] ~ dnorm(mean.phi[i, m], prec.phi[i, m])
      # Prior distribution for non-spatial effects
      theta[i, m] ~ dnorm(0, 1)
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (m in 1:Ndiseases) {
      phi.adj[i, m] <- phi[adj[i], m]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
    prec.phi[1, m] <- pow(sd.phi[m], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, m] <- pow(sd.phi[m], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
    mean.phi[1, m] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], m])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, m] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], m])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Soft sum-to-zero restriction for spatial effects
    ceros[m] <- 0
    ceros[m] ~ dnorm(sum.phi[m], 10)
    sum.phi[m] <- sum(phi[, m])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (m in 1:Ndiseases) {
    sd.phi[m] ~ dunif(0, 5)
    sd.theta[m] ~ dunif(0, 5)
    mu[m] ~ dflat()
  }
}
```

The model without the spatial iid effect theta.
```{r}
# Multivariate region weighted model, WinBUGS code, without iid effect theta
RW_ICAR_NOiid <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (m in 1:Ndiseases) {
      Y[i, m] ~ dpois(lambda[i, m])
      # Modeling of the mean for each region and disease
      log(lambda[i, m]) <- log(E[i, m]) + mu[m] + phi[i,m]
      # Prior distribution for spatial effects
      phi[i, m] ~ dnorm(mean.phi[i, m], prec.phi[i, m])
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (m in 1:Ndiseases) {
      phi.adj[i, m] <- phi[adj[i], m]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
    prec.phi[1, m] <- pow(sd.phi[m], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, m] <- pow(sd.phi[m], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
    mean.phi[1, m] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], m])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, m] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], m])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Soft sum-to-zero restriction for spatial effects
    ceros[m] <- 0
    ceros[m] ~ dnorm(sum.phi[m], 10)
    sum.phi[m] <- sum(phi[, m])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (m in 1:Ndiseases) {
    sd.phi[m] ~ dunif(0, 5)
    mu[m] ~ dflat()
  }
}
```


# Run the model
Now we are ready to run the model in WinBUGS. We choose the mortality causes, either 10, 20 or 50 causes and run the multivariate model.

```{r, eval=FALSE}
#For the model with iid theta, the spatial random effect
# # Initial values
# initials <- function() {
#   list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
#        sd.theta = runif(data$Ndiseases, 0, 1), 
#        phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
#               ncol = data$Ndiseases),
#        theta = matrix(rnorm(data$Nareas * data$Ndiseases),
#               nrow = data$Nareas, ncol = data$Ndiseases), 
#        c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
# }
# # Variables to retrieve
# param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta", "c", "sd.c", "tau")

runtime_RW <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
# Initial values
initials <- function(){
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases), 
       c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
}
# Variables to retrieve
param <- c("mu", "lambda", "sd.phi", "phi", "c", "sd.c", "tau")
# Calls to WinBUGS
results.RW.10 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = RW_ICAR_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_RW[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.RW.20 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = RW_ICAR_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_RW[2] <- t1 - t0

# Only cancers

t0 <- Sys.time()

causes.id <- 7:33 #only the cancer indexes

# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.RW.cancer <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = RW_ICAR_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
#runtime_RW[3] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.RW.50 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = RW_ICAR_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_RW[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.RW.86 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = RW_ICAR_NOiid,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_RW[4] <- t1 - t0

# Comparing runtimes and writing to file

runtime_RW

result_list_RW <- list(results.RW.10, results.RW.20, 
                         results.RW.50, results.RW.86, 
                         runtime_RW, results.RW.cancer)
saveRDS(result_list_RW, file = "Results//result_list_RW.rds") #move it to correct folder afterwards
```

Runtimes for RW model in WinBUGS(cirka): 
10 casues takes 10 min
20 causes takes 20 min
50 causes takes 1h 30 min
86 causes takes 5h 30 min


```{r}
res_list_RW <- readRDS("Results//Results_withScaling_and_without_iidTheta//result_list_RW.rds")

res_list_RW[[5]] #check runtimes

ss_provinces = read_sf("Data/Provinces/Provincias_ETRS89_30N.shp")

ss_ar = read_sf("Data/AutonomousRegions/Comunidades_Autonomas_ETRS89_30N.shp")

ggplot() + geom_sf(data = ss_provinces) + geom_sf(data = ss_ar)

# we only work with mainland Spain, remove the islands

out = c("Islas Baleares", "Las Palmas", "Santa Cruz de Tenerife", "Ceuta", "Melilla")

out2 = c("Canarias", "Islas Baleares", "Ceuta", "Melilla")

ss_provinces = ss_provinces |> filter(!(Texto %in% out))

ss_ar = ss_ar %>% filter(!(Texto %in% out2))

ss_provinces$color10 <- res_list_RW[[1]]$mean$c
ss_provinces$color20 <- res_list_RW[[2]]$mean$c
ss_provinces$color50 <- res_list_RW[[3]]$mean$c
ss_provinces$color86 <- res_list_RW[[4]]$mean$c

#can change the fill=NA to add colours
ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=10 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=20 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=50 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for all n=86 causes")

```

Assessing convergence and other properties of the MCMC simulations.
```{r}
#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list_RW[[1]]$summary[, "Rhat"])
range(res_list_RW[[2]]$summary[, "Rhat"])
range(res_list_RW[[3]]$summary[, "Rhat"])
range(res_list_RW[[4]]$summary[, "Rhat"])
range(res_list_RW[[6]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list_RW[[1]]$summary[, "Rhat"] > 1.1)
which(res_list_RW[[2]]$summary[, "Rhat"] > 1.1)
which(res_list_RW[[3]]$summary[, "Rhat"] > 1.1)
which(res_list_RW[[4]]$summary[, "Rhat"] > 1.1)
which(res_list_RW[[6]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list_RW[[1]]$summary["tau",]
res_list_RW[[2]]$summary["tau",]
res_list_RW[[3]]$summary["tau",]
res_list_RW[[4]]$summary["tau",]
res_list_RW[[6]]$summary["tau",]

#Correlation between the weights c for differing number of causes n
cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```



# The more flexible adaptive multivariate model by Riddervoll/Jo
This model instead uses an adaptive ICAR with an individual precision tau for each pair of neighbors i ~ j. Thus, the number of precision parameters equals the number of edges in the graph, or |E| compared to the number of regions in the model above by Miguel. All the precision have the same gamma prior, in their article with scaled data they used Gamma(1.0, 1.2) with a shape and scale parametrization.

```{r}
#before the WinBUGS code
my_list <- vector("list", 47)
for (i in 1:47) {
  my_list[i] <- rep(0, carto.wb$num[i])  # Initialize each element as an empty list
}

count_num <- 1

#for i = 1
for (j in (index[1]):index[2]){
  my_list[[1]] <- append(my_list[[1]], count_num)
  my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
  count_num <- count_num + 1
}

# for i > 1
for (i in 2:47){ #the number of regions
  for (j in (index[i]+1):index[i+1]){
    if (carto.wb$adj[j]>i){
      my_list[[i]] <- append(my_list[[i]], count_num)
      my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
      count_num <- count_num + 1
    }
  }
} 

my_list <- unlist(my_list, use.names = FALSE)

my_list <- as.integer(my_list[which(my_list != 0)])
```



```{r}
# Multivariate edge weighted model, WinBUGS code and iid spatial effect theta
EW_ICAR_withIID <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (m in 1:Ndiseases) {
      Y[i, m] ~ dpois(lambda[i, m])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, m]) <- log(E[i, m]) + mu[m] + phi[i,m] + sd.theta[m] * theta[i, m]
      # Prior distribution for spatial effects
      phi[i, m] ~ dnorm(mean.phi[i, m], prec.phi[i, m])
      # Prior distribution for non-spatial effects
      theta[i, m] ~ dnorm(0, 1)
    }
  }
  
  for (i in 1:n.adj) {
    for (m in 1:Ndiseases) {
      phi.adj[i, m] <- phi[adj[i], m]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
     prec.phi[1, m] <- pow(sd.phi[m], -2) * sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, m] <- pow(sd.phi[m], -2) * sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting too many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  
  # Mean of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
      mean.phi[1, m] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], m])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, m] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], m])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[m] <- 0
    ceros[m] ~ dnorm(sum.phi[m], 10)
    sum.phi[m] <- sum(phi[, m])
  }
  # Prior distributions for Tau2 and its hyperparameters
  for (t in 1:(n.adj/2)){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, )
  }
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (m in 1:Ndiseases) {
    sd.phi[m] ~ dunif(0, 5)
    sd.theta[m] ~ dunif(0, 5)
    mu[m] ~ dflat()
  }
}
```

The model without spatial iid effect theta to focus on the spatially structured effect phi.

```{r}
# Multivariate edge weighted model, WinBUGS code without spatial iid effect theta
EW_ICAR_NOiid <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (m in 1:Ndiseases) {
      Y[i, m] ~ dpois(lambda[i, m])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, m]) <- log(E[i, m]) + mu[m] + phi[i,m]
      # Prior distribution for spatial effects
      phi[i, m] ~ dnorm(mean.phi[i, m], prec.phi[i, m])
    }
  }
  
  for (i in 1:n.adj) {
    for (m in 1:Ndiseases) {
      phi.adj[i, m] <- phi[adj[i], m]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
     prec.phi[1, m] <- pow(sd.phi[m], -2) * sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, m] <- pow(sd.phi[m], -2) * sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting too many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  
  # Mean of the conditional distribution of spatial effects
  for (m in 1:Ndiseases) {
      mean.phi[1, m] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], m])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, m] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], m])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[m] <- 0
    ceros[m] ~ dnorm(sum.phi[m], 10)
    sum.phi[m] <- sum(phi[, m])
  }
  # Prior distributions for Tau2 and its hyperparameters
  for (t in 1:(n.adj/2)){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, )
  }
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (m in 1:Ndiseases) {
    sd.phi[m] ~ dunif(0, 5)
    mu[m] ~ dflat()
  }
}
```


```{r, eval=FALSE}
runtime_EW <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index, 
             tau.list = my_list)
#For the model with iid spatial effect theta
# # Initial values
# initials_EW <- function() {
#   list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
#        sd.theta = runif(data$Ndiseases, 0, 1), 
#        phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
#               ncol = data$Ndiseases),
#        theta = matrix(rnorm(data$Nareas * data$Ndiseases),
#               nrow = data$Nareas, ncol = data$Ndiseases), 
#        Tau2 = runif(data$n.adj/2, 0.5, 3))
# }
# 
# # Variables to retrieve
# param_EW <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta", "Tau2", "sd.alpha", "alpha")

# Initial values
initials_EW <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1),
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas,
              ncol = data$Ndiseases),
       Tau2 = runif(data$n.adj/2, 0.5, 3))
}

# Variables to retrieve
param_EW <- c("mu", "lambda", "sd.phi", "phi", "Tau2", "sd.alpha", "alpha")

# Calls to WinBUGS
results.EW.10 <- pbugs(data = data, inits = initials_EW,
                              parameters.to.save = param_EW, model = EW_ICAR_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_EW[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.EW.20 <- pbugs(data = data, inits = initials_EW,
                              parameters.to.save = param_EW, model = EW_ICAR_NOiid,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_EW[2] <- t1 - t0

# All cancers

t0 <- Sys.time()

causes.id <- 7:33 # indexes for the cancers

# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.EW.cancer <- pbugs(data = data, inits = initials_EW,
                              parameters.to.save = param_EW, model = EW_ICAR_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
#runtime_EW[3] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.EW.50 <- pbugs(data = data, inits = initials_EW,
                              parameters.to.save = param_EW, model = EW_ICAR_NOiid,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_EW[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(Y = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index,
             tau.list = my_list)

# Calls to WinBUGS
results.EW.86 <- pbugs(data = data, inits = initials_EW,
                              parameters.to.save = param_EW, model = EW_ICAR_NOiid,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_EW[4] <- t1 - t0


# Comparing runtimes

runtime_EW

result_list_EW <- list(results.EW.10, results.EW.20, results.EW.50, 
                    results.EW.86, runtime_EW, results.EW.cancer)
saveRDS(result_list_EW, file = "Results//result_list_EW.rds") #then move to correct folder
```

Assessing convergence and other properties of the MCMC simulations.

```{r}
res_list_EW <- readRDS("Results//Results_withScaling_and_without_iidTheta//result_list_EW.rds")

res_list_EW[[5]]

#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list_EW[[1]]$summary[, "Rhat"])
range(res_list_EW[[2]]$summary[, "Rhat"])
range(res_list_EW[[3]]$summary[, "Rhat"])
range(res_list_EW[[4]]$summary[, "Rhat"])
range(res_list_EW[[6]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list_EW[[1]]$summary[, "Rhat"] > 1.1)
which(res_list_EW[[2]]$summary[, "Rhat"] > 1.1)
which(res_list_EW[[3]]$summary[, "Rhat"] > 1.1)
which(res_list_EW[[4]]$summary[, "Rhat"] > 1.1)
which(res_list_EW[[6]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list_EW[[1]]$summary["alpha",]
res_list_EW[[2]]$summary["alpha",]
res_list_EW[[3]]$summary["alpha",]
res_list_EW[[4]]$summary["alpha",]
res_list_EW[[6]]$summary["alpha",]

res_list_EW[[1]]$mean$Tau2
res_list_EW[[4]]$mean$Tau2

```

#Plots and visualization of results

Plots and visualization of the results. The plot with colored provinces represents the precision in each region, which equals the sum of the precision of the connected edges. Additionally, the plot with colored edges represents the precision of each edge, not sure how to make this yet. Ideally the plot has different colors for the edges, and the autonomous region borders are also thicker, so they are visible in the figure. Maybe they are lower precision mostly??


#Edgeplots for the WinBUGS models by Miguel and Jo
Lets make the edgeplots for each number n of causes for each of the two models and summarise it in a 4X2 figure.

## Edgeplots for the EW-ICAR

The indexing actually works out nicely. So, the way I constructed my_list aligns with how the edge_list gets the neighbors from the shape file (from chatGPT). 

```{r}
#Plots for the precision of each edge
library(sf)
library(spdep)
library(ggplot2)
library(dplyr)

# Compute centroids
centroids <- st_centroid(ss_provinces)

# Create an adjacency list
nb <- poly2nb(ss_provinces)

# Create an empty list to store edges and metadata
edge_list <- list()
region_from <- c()
region_to <- c()

# Loop through each region to create edges and store region names/IDs
for (i in seq_along(nb)) {
  neighbors <- nb[[i]]
  if (length(neighbors) == 0) next
  
  for (j in neighbors) {
    # Store the line geometry
    edge_list <- append(edge_list, 
                        list(st_linestring(rbind(st_coordinates(centroids[i, ]), 
                                                 st_coordinates(centroids[j, ])))))
    
    # Store region names or IDs
    region_from <- c(region_from, i)  # Replace 'NAME' with the correct column name
    region_to <- c(region_to, j)
  }
}

# Convert to an sf object
edges_sf <- st_sf(geometry = st_sfc(edge_list, crs = st_crs(ss_provinces)), 
                  from = region_from, to = region_to)

#Add the precisions/linewidth
# tau_list is the 111 precisions for the edges
example_tau_list <- c(rep(1, 50), rep(3, 61))
#edge_weight <- rep(0, nrow(edges_sf))
#edge_weight <- tau_list[my_list] #so 222 edge weights, two equal weights for each edge

#edges_sf$edge_value <- edge_weight
edges_sf$example_edge_value <- example_tau_list[my_list]
edges_sf$edge_value_EW_10 <- res_list_EW[[1]]$mean$Tau2[my_list]*
      mean(1/(res_list_EW[[1]]$mean$sd.phi)^2)
edges_sf$edge_value_EW_20 <- res_list_EW[[2]]$mean$Tau2[my_list]*
      mean(1/(res_list_EW[[2]]$mean$sd.phi)^2)
edges_sf$edge_value_EW_50 <- res_list_EW[[3]]$mean$Tau2[my_list]*
      mean(1/(res_list_EW[[3]]$mean$sd.phi)^2)
edges_sf$edge_value_EW_86 <- res_list_EW[[4]]$mean$Tau2[my_list]*
      mean(1/(res_list_EW[[4]]$mean$sd.phi)^2)
edges_sf$edge_value_EW_cancer <- res_list_EW[[6]]$mean$Tau2[my_list]*
      mean(1/(res_list_EW[[6]]$mean$sd.phi)^2)

# Example plot with varying edge widths
ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 3) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = example_edge_value), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  # Adjust thickness range
  ggtitle("Example plot for edges with different precisions") +
  theme_minimal()

# 10 causes
edgeplot_EW_10 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_EW_10), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank())  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 20 causes
edgeplot_EW_20 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_EW_20), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank())  +
   guides(linewidth = guide_legend(title = "Width mapping"))

# 50 causes
edgeplot_EW_50 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_EW_50), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),  
        axis.title = element_blank()) +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 86 causes
edgeplot_EW_86 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_EW_86), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(x = "EW-ICAR") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
```


## Edge plots for Miguels RW-ICAR and for Jo's EW-ICAR 
For this model the outputs are the weights c, one for each region. The precision for a given edge between neighbors is then the product of the c's in the two provinces. We get the following relation between $\tau_{ij}$ and $c_i$ and $c_j$:
$$
\tau_{ij} = \sqrt{c_i*c_j}
$$
Additionally, it is important that the calculated tau's match with the positions from the EW model above. Now lets calculate the tau's.
```{r}
nAreas <- length(carto.wb$num)
nEdges <- length(carto.wb$adj)/2

#the scaling tau averaged over all the causes of death for each n
# mean(1/(res_list_RW[[1]]$mean$sd.phi)^2)
# mean(1/(res_list_RW[[2]]$mean$sd.phi)^2)
# mean(1/(res_list_RW[[3]]$mean$sd.phi)^2)
# mean(1/(res_list_RW[[4]]$mean$sd.phi)^2)

# 10 causes
count_num <- 1
tau_list_RW_10 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_RW_10[count_num] <- sqrt(res_list_RW[[1]]$mean$c[i]*
              res_list_RW[[1]]$mean$c[j]) * mean(1/(res_list_RW[[1]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 20 causes
count_num <- 1
tau_list_RW_20 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_RW_20[count_num] <- sqrt(res_list_RW[[2]]$mean$c[i]*
            res_list_RW[[2]]$mean$c[j])*mean(1/(res_list_RW[[2]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# all cancers
count_num <- 1
tau_list_RW_cancer <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_RW_cancer[count_num] <- sqrt(res_list_RW[[6]]$mean$c[i]*
            res_list_RW[[6]]$mean$c[j])*mean(1/(res_list_RW[[6]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 50 causes
count_num <- 1
tau_list_RW_50 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_RW_50[count_num] <- sqrt(res_list_RW[[3]]$mean$c[i]*
              res_list_RW[[3]]$mean$c[j])*mean(1/(res_list_RW[[3]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

# 86 causes
count_num <- 1
tau_list_RW_86 <- rep(0, sum(carto.wb$num))
for (i in 1:nAreas){
  for (j in carto.nb[[i]]){
    tau_list_RW_86[count_num] <- sqrt(res_list_RW[[4]]$mean$c[i]*
            res_list_RW[[4]]$mean$c[j])*mean(1/(res_list_RW[[4]]$mean$sd.phi)^2)
    count_num <- count_num + 1
  }
}

edges_sf$edge_value_RW_10 <- tau_list_RW_10
edges_sf$edge_value_RW_20 <- tau_list_RW_20
edges_sf$edge_value_RW_cancer <- tau_list_RW_cancer
edges_sf$edge_value_RW_50 <- tau_list_RW_50
edges_sf$edge_value_RW_86 <- tau_list_RW_86

#Making the plots

# 10 causes
edgeplot_RW_10 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_RW_10), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(y = "n = 10") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 20 causes
edgeplot_RW_20 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_RW_20), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) + 
  labs(y = "n = 20") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))

# 50 causes
edgeplot_RW_50 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_RW_50), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) + 
  labs(y = "n = 50") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.y = element_text(size = 18))  +
   guides(linewidth = guide_legend(title = "Width mapping"))
  
# 86 causes
edgeplot_RW_86 <- ggplot() +
  geom_sf(data = ss_provinces, fill = NA, color = "grey") +  # Provinces
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) + # Autonomous regions
  geom_sf(data = centroids, color = "red", size = 2) +  # Centroids
  geom_sf(data = edges_sf, aes(linewidth = edge_value_RW_86), color = "blue") + 
  scale_linewidth(range = c(0.2, 1.7)) +  
  labs(x = "RW-ICAR", y = "n = 86") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(linewidth = guide_legend(title = "Width mapping"))

```

## Plot them all together in one figure

Now lets collect all the plots in an edgeplot figure:
```{r}
library(ggpubr)

edgeplots <- list(edgeplot_RW_10, edgeplot_EW_10, edgeplot_RW_20, edgeplot_EW_20,
               edgeplot_RW_50, edgeplot_EW_50, edgeplot_RW_86, edgeplot_EW_86)

final_edgeplot <- ggarrange(plotlist = edgeplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//Plots_withScaling_and_without_iidTheta_withCancer//edgeFigure.png", plot = final_edgeplot, height = 24, width = 21,  units = "cm",  dpi = 300)
```


# Plots of the total precision for each regions for the WinBUGS models
Plot of the total precision, i.e. the sum of the precision of the connected edges for all regions. Lets start with making the plots for the temporal EW by Jo and Riddervold.

## Total precision per region for EW-ICAR

As this model calculates the precision tau for each edge, the precision for each region is simply the sum of the connecting edges. Lets first compute these sums before making the plots for each number of causes $n$.

```{r}
#Plot for the total precision of each region

# 10 causes
precision_list10 <- rep(0, nAreas) 
tau_list <- res_list_EW[[1]]$mean$Tau2*mean(1/(res_list_EW[[1]]$mean$sd.phi)^2)

precision_list10[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list10[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 20 causes
precision_list20 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_EW[[2]]$mean$Tau2*mean(1/(res_list_EW[[2]]$mean$sd.phi)^2)

precision_list20[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list20[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 50 causes
precision_list50 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_EW[[3]]$mean$Tau2*mean(1/(res_list_EW[[3]]$mean$sd.phi)^2)

precision_list50[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list50[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

# 86 causes
precision_list86 <- rep(0, nAreas) #maybe define nAreas at the start?
tau_list <- res_list_EW[[4]]$mean$Tau2*mean(1/(res_list_EW[[4]]$mean$sd.phi)^2)

precision_list86[1] <- sum(tau_list[my_list[index[1]:index[2]]])
for (i in 2:nAreas){
  precision_list86[i] <- sum(tau_list[my_list[(index[i] + 1):index[i + 1]]])
}

ss_provinces$color10_EW <- precision_list10
ss_provinces$color20_EW <- precision_list20
ss_provinces$color50_EW <- precision_list50
ss_provinces$color86_EW <- precision_list86

#can change the fill=NA to add colours
precplot_EW_10 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10_EW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_EW_20 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20_EW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_EW_50 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50_EW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_EW_86 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86_EW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4)  +
  labs(x = "EW-ICAR") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))
```

## Precision plots for the RW-ICAR by Miguel


```{r}
#Plot for the total precision of each region

# 10 causes
precision_list10 <- rep(0, nAreas) 

precision_list10[1] <- sum(tau_list_RW_10[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list10[i] <- sum(tau_list_RW_10[(index[i] + 1):index[i + 1]])
}

# 20 causes
precision_list20 <- rep(0, nAreas)

precision_list20[1] <- sum(tau_list_RW_20[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list20[i] <- sum(tau_list_RW_20[(index[i] + 1):index[i + 1]])
}

# 50 causes
precision_list50 <- rep(0, nAreas) 

precision_list50[1] <- sum(tau_list_RW_50[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list50[i] <- sum(tau_list_RW_50[(index[i] + 1):index[i + 1]])
}

# 86 causes
precision_list86 <- rep(0, nAreas) 

precision_list86[1] <- sum(tau_list_RW_86[index[1]:index[2]])
for (i in 2:nAreas){
  precision_list86[i] <- sum(tau_list_RW_86[(index[i] + 1):index[i + 1]])
}

ss_provinces$color10_RW <- precision_list10
ss_provinces$color20_RW <- precision_list20
ss_provinces$color50_RW <- precision_list50
ss_provinces$color86_RW <- precision_list86

#can change the fill=NA to add colours
precplot_RW_10 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10_RW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 10") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_RW_20 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20_RW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 20") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_RW_50 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50_RW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(y = "n = 50") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))

precplot_RW_86 <- ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86_RW), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  labs(x = "RW-ICAR",y = "n = 86") +
  theme_minimal() +
  theme(axis.text = element_blank(),axis.ticks = element_blank(),
        axis.title.x = element_text(size = 18), axis.title.y = element_text(size = 18)) +
   guides(fill = guide_colorbar(title = "Color mapping"))
```

## Collecting the 8 precision plots in the same figure

```{r}
precplots <- list(precplot_RW_10, precplot_EW_10, precplot_RW_20, precplot_EW_20,
               precplot_RW_50, precplot_EW_50, precplot_RW_86, precplot_EW_86)

final_precplot <- ggarrange(plotlist = precplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//Plots_withScaling_and_without_iidTheta_withCancer//precFigure.png", plot = final_precplot, height = 24, width = 21,  units = "cm",  dpi = 300)
```


# Scatterplots for comparing the two WinBUGS models and an Anova comparison
The scatterplots are again 8 plots, 4 for precision in each region and 4 for the precision in edges. They are both for each number of causes n = 10, 20, 50, 86. For edges, the edges within an autonomous region should be one color while edges between autonomous regions should be another. This is also the split for the anova test. Lets start be dividing the precisions for the edges in the two groups.

```{r}
# So we have a vector of 111, or 222, precisions for the edges
#edges_sf$edge_value_EW_10 #format for EW
#edges_sf$edge_value_RW_10 #format for RW
#index2 <- index
#index2[1] <- 0 #so the first node works as the rest, i.e. from index[t]+1:index[t+1] 

#Lets make a vector indicating the groups by 0 or 1
inter_region_edges <- rep(0, nEdges*2) #nEdges is 111
sum(inter_region_edges)
for (i in 1:(nEdges*2)){
  reg1 <- edges_sf$from[i] #index of the from region
  reg2 <- edges_sf$to[i]   #index of the to region
  if (carto$CCAA_Index[reg1] == carto$CCAA_Index[reg2]){
    inter_region_edges[i] <- 1
  }
}

between_region_edges <- 1 - inter_region_edges
edges_sf$inter_region_edges <- inter_region_edges
edges_sf$between_region_edges <- between_region_edges
```

## Scatterplots for the edges for the WinBUGS models
Lets now make the four plots for the different number of causes n.

```{r}
# 10 causes
cor_edges_10 <- cor(edges_sf$edge_value_RW_10, edges_sf$edge_value_EW_10)

SCplot_edges_10 <- ggplot(edges_sf, aes(x = edge_value_RW_10, y = edge_value_EW_10, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_10, 3), "(n = 10)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 20 causes
cor_edges_20 <- cor(edges_sf$edge_value_RW_20, edges_sf$edge_value_EW_20)

SCplot_edges_20 <- ggplot(edges_sf, aes(x = edge_value_RW_20, y = edge_value_EW_20, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_20, 3), "(n = 20)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 50 causes
cor_edges_50 <- cor(edges_sf$edge_value_RW_50, edges_sf$edge_value_EW_50)

SCplot_edges_50 <- ggplot(edges_sf, aes(x = edge_value_RW_50, y = edge_value_EW_50, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_50, 3), "(n = 50)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

# 86 causes
cor_edges_86 <- cor(edges_sf$edge_value_RW_86, edges_sf$edge_value_EW_86)

SCplot_edges_86 <- ggplot(edges_sf, aes(x = edge_value_EW_86, y = edge_value_EW_86, 
                     color = factor(inter_region_edges))) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_edges_86, 3), "(n = 86)")) + 
  scale_color_manual(values = c("0" = "red", "1" = "blue")) +
  guides(color = "none")

```
For the above plots, red correspond to edges between different autonomous regions while blue are edges inside the same autonomous region.

## Scatter plots for total precision in each region

```{r}
# 10 causes
cor_prec_10 <- cor(ss_provinces$color10_RW, ss_provinces$color10_EW)

SCplot_prec_10 <- ggplot(ss_provinces, aes(x = color10_RW, y = color10_EW)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR", 
       title = paste("Cor =", round(cor_prec_10, 3), "(n = 10)"))

# 20 causes
cor_prec_20 <- cor(ss_provinces$color20_RW, ss_provinces$color20_EW)

SCplot_prec_20 <- ggplot(ss_provinces, aes(x = color20_RW, y = color20_EW)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_20, 3), "(n = 20)"))

# 50 causes
cor_prec_50 <- cor(ss_provinces$color50_RW, ss_provinces$color50_EW)

SCplot_prec_50 <- ggplot(ss_provinces, aes(x = color50_RW, y = color50_EW)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_50, 3), "(n = 50)"))

# 86 causes
cor_prec_86 <- cor(ss_provinces$color86_RW, ss_provinces$color86_EW)

SCplot_prec_86 <- ggplot(ss_provinces, aes(x = color86_RW, y = color86_EW)) +
  geom_point() +
  labs(x = "RW-ICAR", y = "EW-ICAR",
       title = paste("Cor =", round(cor_prec_86, 3), "(n = 86)"))
```

## Collecting the 8 scatterplots in the same figure

```{r}
scatterplots <- list(SCplot_edges_10, SCplot_prec_10, SCplot_edges_20, SCplot_prec_20,
                     SCplot_edges_50, SCplot_prec_50, SCplot_edges_86, SCplot_prec_86)

final_scatterplot <- ggarrange(plotlist = scatterplots, ncol = 2, nrow = 4, labels = NULL)

#ggsave("Plots//Plots_withScaling_and_without_iidTheta_withCancer//scatterFigure.png", plot = final_scatterplot, height = 24, width = 21,  units = "cm",  dpi = 300)

#save the edges_sf for use in the CV
#saveRDS(edges_sf, file = "Edges_df//Edges_W_scaling_WO_theta")
```


#Anova test for edges for differing number of causes n
At the log scale for the precisions!

```{r}

anova_EW_10 <- summary(aov(log(edges_sf$edge_value_EW_10) ~ 
                                edges_sf$between_region_edges))
anova_EW_20 <- summary(aov(log(edges_sf$edge_value_EW_20) ~
                                edges_sf$between_region_edges))
anova_EW_50 <- summary(aov(log(edges_sf$edge_value_EW_50) ~
                                edges_sf$between_region_edges))
anova_EW_86 <- summary(aov(log(edges_sf$edge_value_EW_86) ~
                                edges_sf$between_region_edges))

anova_RW_10 <- summary(aov(log(edges_sf$edge_value_RW_10) ~
                               edges_sf$between_region_edges))
anova_RW_20 <- summary(aov(log(edges_sf$edge_value_RW_20) ~
                               edges_sf$between_region_edges))
anova_RW_50 <- summary(aov(log(edges_sf$edge_value_RW_50) ~
                               edges_sf$between_region_edges))
anova_RW_86 <- summary(aov(log(edges_sf$edge_value_RW_86) ~
                               edges_sf$between_region_edges))

anova_result_log <- c(anova_EW_10[[1]][1, "Pr(>F)"], anova_EW_20[[1]][1, "Pr(>F)"], 
                  anova_EW_50[[1]][1, "Pr(>F)"], anova_EW_86[[1]][1, "Pr(>F)"],
                  anova_RW_10[[1]][1, "Pr(>F)"], anova_RW_20[[1]][1, "Pr(>F)"],
                  anova_RW_50[[1]][1, "Pr(>F)"], anova_RW_86[[1]][1, "Pr(>F)"])

anova_result_log <- round(anova_result_log,  4)

anova_log_df <- data.frame(RW = anova_result_log[5:8],
                       EW = anova_result_log[1:4])

row.names(anova_log_df) <- c("n=10", "n=20", "n=50", "n=86")
colnames(anova_log_df) <- c("RW-ICAR", "EW-ICAR")

anova_log_edge_table <- ggtexttable(anova_log_df, theme = ttheme("mOrange"))

#ggsave("Plots//Plots_withScaling_and_without_iidTheta_withCancer//anovaLogFigure.png", plot = anova_log_edge_table, height = 12, width = 10,  units = "cm",  dpi = 300)
```

# Correlation between the precision matrices for different n's for both EW and RW

## First for EW-ICAR
```{r}
#Correlation between the weights c for differing number of causes n

# Load libraries
library(gt)
library(tibble)
library(webshot2)

df_corr_EW <- round(cor(cbind(edges_sf$edge_value_EW_10, edges_sf$edge_value_EW_20,
                                 edges_sf$edge_value_EW_50, edges_sf$edge_value_EW_86)),
                           4)
                                 
                            

df_corr_EW <- as.matrix(df_corr_EW)

rownames(df_corr_EW) <- c("n=10", "n=20", "n=50", "n=86")
colnames(df_corr_EW) <- c("n=10", "n=20", "n=50", "n=86")

df_corr_tbl <- as.data.frame(df_corr_EW)
df_corr_tbl <- tibble::rownames_to_column(df_corr_tbl, var = "Sample size")

# Create gt table
gt_table <- gt(df_corr_tbl) |>
  cols_label(`Sample size` = "") |> 
  tab_header(title = "Correlation for EW-ICAR") |>
  fmt_number(columns = -`Sample size`, decimals = 3) |>
  tab_style(style = cell_fill(color = "#F9F9F9"), locations = cells_body()) |>
  tab_style(style = list(cell_fill(color = "#EAEAEA"), cell_text(weight = "bold")), 
            locations = cells_column_labels()) |>
  tab_style(style = list(cell_fill(color = "#EAEAEA"), cell_text(weight = "bold")),
    locations = cells_stub())

# Print
gt_table

#gtsave(gt_table, "Plots//Plots_withScaling_and_without_iidTheta_withCancer//correlation_matrix_EW.png")
```

## Then for RW-ICAR
```{r}
df_corr_RW <- round(cor(cbind(edges_sf$edge_value_RW_10, edges_sf$edge_value_RW_20,
                                 edges_sf$edge_value_RW_50, edges_sf$edge_value_RW_86)),
                           4)

df_corr_RW <- as.matrix(df_corr_RW)

rownames(df_corr_RW) <- c("n=10", "n=20", "n=50", "n=86")
colnames(df_corr_RW) <- c("n=10", "n=20", "n=50", "n=86")

df_corr_tbl <- as.data.frame(df_corr_RW)
df_corr_tbl <- tibble::rownames_to_column(df_corr_tbl, var = "Sample size")

# Create gt table
gt_table <- gt(df_corr_tbl) |>
  cols_label(`Sample size` = "") |> 
  tab_header(title = "Correlation for RW-ICAR") |>
  fmt_number(columns = -`Sample size`, decimals = 3) |>
  tab_style(style = cell_fill(color = "#F9F9F9"), locations = cells_body()) |>
  tab_style(style = list(cell_fill(color = "#EAEAEA"), cell_text(weight = "bold")), 
            locations = cells_column_labels()) |>
  tab_style(style = list(cell_fill(color = "#EAEAEA"), cell_text(weight = "bold")),
    locations = cells_stub())

# Print
gt_table

#gtsave(gt_table, "Plots//Plots_withScaling_and_without_iidTheta_withCancer//correlation_matrix_RW.png")
```





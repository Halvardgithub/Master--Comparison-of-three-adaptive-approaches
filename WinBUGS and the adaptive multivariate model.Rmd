---
title: "WinBUGS model"
author: "Halvard"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(R2WinBUGS)

#remotes::install_github("fisabio/pbugs")
library(pbugs)

library(readr)
library(ggplot2)

library(sf)
library(spdep)
library(dplyr)
```

### Loading data
Load the data and spatial structures.
```{r}
ExpectedCases <- readRDS("ExpectedCasesMiguel.rds")
ObservedCases <- readRDS("ObservedCases.rds")
PopulationData <- readRDS("PopulationData.rds")
nDiseasesTot <- as.numeric(ncol(ObservedCases)) #the number of causes

shp_prov <- st_read("Data/Provinces/Provincias_ETRS89_30N.shp")
colnames(shp_prov) <- c("Index", "ProvName", "ProvName1", "CCAA_Index", "CCAA_Name", "geometry")
CCAA_to_remove <- c("Illes Balears", "Canarias", "Ceuta", "Melilla")
shp_prov <- filter(shp_prov, !CCAA_Name %in% CCAA_to_remove)
carto <- shp_prov

#Spatial structure
carto.nb <- poly2nb(carto) # Neighbours list of each geographic unit with class nb
carto.wb <- nb2WB(carto.nb) # List with the adjacency vector (carto.wb$adj) and
# the number of neighbors of each geographic unit (carto.wb$num) to use in WinBUGS
index <- c(1, cumsum(carto.wb$num)) # Vector to identify the positions of the neighbors
# of each geographic unit in the conditional distributions of spatial effects

#Randomize disease from 1-102 and do not need sex I think, numbers are 10, 20 and 50
get_causes <- function(n){ #nDiseasesTot is defined further up
  set.seed(12345)
  subset <- sample(1:nDiseasesTot, n, replace = FALSE) #there is a total of 102 diseases
  return(sort(subset))
}

causes10 <- get_causes(10) #the indexes corresponding to 10 random diseases, if n=20 we keep the first 10 and get 10 new ones
causes20 <- get_causes(20)
causes50 <- get_causes(50)
causes86 <- get_causes(86)


# exp10 <- ExpectedCases[, causes10]
# exp20 <- ExpectedCases[, causes20]
# exp50 <- ExpectedCases[, causes50]
# 
# obs10 <- ObservedCases[, causes10]
# obs20 <- ObservedCases[, causes20]
# obs50 <- ObservedCases[, causes50]

```
Note that "Tumor Maligno del cruello del utero" in exp10 are all zero, so should be removed from the original datasets."Tumores in suto" is also extremely low. "XV.Embarazo, parto y puerpeira" as well. There is also some for homocides and maybe also accidents and such. 

### Implement the multivariate adaptive model with WinBUGS

Generally, i indicates a spatial region/province and j represents a disease or cause of death. 
```{r}
# Multivariate adaptive BYM model, WinBUGS code
AdaptiveBYM_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  for (i in 1:n.adj) {
    sqrt.c.adj[i] <- sqrt(c[adj[i]])
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }
  # Precision of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    prec.phi[1, j] <- pow(sd.phi[j], -2) * sqrt(c[1]) * sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      prec.phi[i, j] <- pow(sd.phi[j], -2) * sqrt(c[i]) * sum(sqrt.c.adj[(index[i] + 1):index[i + 1]]) #the +1 is to correct the indexes, works as all regions have at least one neighbour
    } 
  } 
  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
    mean.phi[1, j] <- inprod2(sqrt.c.adj[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(sqrt.c.adj[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(sqrt.c.adj[(index[i] + 1):index[i + 1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(sqrt.c.adj[(index[i] + 1):index[i +1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  # Prior distributions for c
  for (i in 1:Nareas) {
    c[i] ~ dgamma(tau, tau) %_% I(0.001, ) # %_% 0.001 ensures c[i] is above 0.001
  }
  tau <- pow(sd.c, -2)
  sd.c ~ dunif(0, 5)
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```


# Run the model
Now we are ready to run the model in WinBUGS. We choose the mortality causes, either 10, 20 or 50 causes and run the multivariate model.

```{r, eval=TRUE}
runtime_ABYM <- rep(0, 4)

# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
# Initial values
initials <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       sd.theta = runif(data$Ndiseases, 0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases),
       theta = matrix(rnorm(data$Nareas * data$Ndiseases),
              nrow = data$Nareas, ncol = data$Ndiseases), 
       c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
}
# Variables to retrieve
param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")
# Calls to WinBUGS
results.AdaptiveBYM.10 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.20 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.50 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.AdaptiveBYM.86 <- pbugs(data = data, inits = initials,
                              parameters.to.save = param, model = AdaptiveBYM_model,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_ABYM[4] <- t1 - t0

# Comparing runtimes

runtime_ABYM

result_list_ABYM <- list(results.AdaptiveBYM.10, results.AdaptiveBYM.20, 
                         results.AdaptiveBYM.50, results.AdaptiveBYM.86)
saveRDS(result_list_ABYM, file = "Results//result_list_longer_chains.rds")
```

Runtimes: 
10 casues takes 10 min
20 causes takes 20 min
50 causes takes 1h 30 min
86 causes takes 5h 30 min


```{r}
res_list <- readRDS("Results//result_list_longer_chains.rds")

ss_provinces = read_sf("Data/Provinces/Provincias_ETRS89_30N.shp")

ss_ar = read_sf("Data/AutonomousRegions/Comunidades_Autonomas_ETRS89_30N.shp")

ggplot() + geom_sf(data = ss_provinces) + geom_sf(data = ss_ar)

# we only work with mainland Spain, remove the islands

out = c("Islas Baleares", "Las Palmas", "Santa Cruz de Tenerife", "Ceuta", "Melilla")

out2 = c("Canarias", "Islas Baleares", "Ceuta", "Melilla")

ss_provinces = ss_provinces |> filter(!(Texto %in% out))

ss_ar = ss_ar %>% filter(!(Texto %in% out2))

ss_provinces$color10 <- res_list[[1]]$mean$c
ss_provinces$color20 <- res_list[[2]]$mean$c
ss_provinces$color50 <- res_list[[3]]$mean$c
ss_provinces$color86 <- res_list[[4]]$mean$c

#can change the fill=NA to add colours
ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color10), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=10 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color20), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=20 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color50), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for n=50 causes")

ggplot() +
  geom_sf(data = ss_ar, color="black") + #do not really need this line
  geom_sf(data=ss_provinces, aes(fill=color86), color="grey") +
  geom_sf(data = ss_ar, color="black", fill=NA,linewidth = 0.4) +
  ggtitle("Weights c for all n=86 causes")

```

Assessing convergence and other properties of the MCMC simulations.
```{r}
#check the Rhat's for convergence, should be less than 1.1 for all parameters
range(res_list[[1]]$summary[, "Rhat"])
range(res_list[[2]]$summary[, "Rhat"])
range(res_list[[3]]$summary[, "Rhat"])
range(res_list[[4]]$summary[, "Rhat"])

#Which(if any) are greater than 1.1
which(res_list[[1]]$summary[, "Rhat"] > 1.1)
which(res_list[[2]]$summary[, "Rhat"] > 1.1)
which(res_list[[3]]$summary[, "Rhat"] > 1.1)
which(res_list[[4]]$summary[, "Rhat"] > 1.1)

#Check the parameter tau for the weights c with prior Gamma(tau, tau)
res_list[[1]]$summary["tau",]
res_list[[2]]$summary["tau",]
res_list[[3]]$summary["tau",]
res_list[[4]]$summary["tau",]

#Correlation between the weights c for differing number of causes n
cor(cbind(ss_provinces$color10, ss_provinces$color20, ss_provinces$color50, ss_provinces$color86))
```




## For leave one out cross-validation for the diseases and simulation of the weight matrix
```{r}
# Object where the results for each set of diseases will be
# saved
results.AdaptiveBYM <- list()
# Run multivariate adaptive BYM model for each set of
# diseases
causes <- causes10
for (i in 1:length(causes)) { #corresponds to the n in the line above
  # Selection of mortality causes
  causes.id <- causes[-c(i)]
  # Data
  data <- list(O = ObservedCases, E = ExpectedCases,
               Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
               n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)
  # Initial values
  initials <- function() {
    list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
         sd.theta = runif(data$Ndiseases, 0, 1), 
         phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
                ncol = data$Ndiseases),
         theta = matrix(rnorm(data$Nareas * data$Ndiseases),
                nrow = data$Nareas, ncol = data$Ndiseases), 
         c = runif(data$Nareas,0.9, 1.1), sd.c = runif(1, 0.5, 0.6))
  }
  # Variables to retrieve
  param <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "c", "sd.c", "tau")
  # Calls to WinBUGS
  results.AdaptiveBYM[[i]] <- bugs(data = data, inits = initials,
                                    parameters.to.save = param, model = AdaptiveBYM_model,
                                    n.iter = 20, n.burnin = 10, n.chains = 3, DIC = F,
                                   debug = F)
}
# Save results
write_csv(results.AdaptiveBYM, file = "Results/results.AdaptiveBYM-Miguel.csv")


```

It gave an error called trap 66, which means it failed in WinBUGS I believe.


Meeting at wednesday 9.15
and monday at 11:00.



# The more flexible adaptive multivariate model by Riddervoll/Jo
This model instead uses an adaptive ICAR with an individual precision tau for each pair of neighbors i ~ j. Thus, the number of precision parameters equals the number of edges in the graph, or |E| compared to the number of regions in the model above by Miguel. All the precision have the same gamma prior, in their article with scaled data they used Gamma(1.0, 1.2) with a shape and scale parametrization.

```{r}

#before the WinBUGS code
my_list <- vector("list", 47)
for (i in 1:47) {
  my_list[i] <- rep(0, carto.wb$num[i])  # Initialize each element as an empty list
}

count_num <- 1

#for i = 1
for (j in (index[1]):index[2]){
  my_list[[1]] <- append(my_list[[1]], count_num)
  my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
  count_num <- count_num + 1
}

# for i > 1
for (i in 2:47){ #the number of regions
  for (j in (index[i]+1):index[i+1]){
    if (carto.wb$adj[j]>i){
      my_list[[i]] <- append(my_list[[i]], count_num)
      my_list[[carto.wb$adj[j]]] <- append(my_list[[carto.wb$adj[j]]], count_num)
      count_num <- count_num + 1
    }
  }
} 

my_list <- unlist(my_list, use.names = FALSE)

my_list <- as.integer(my_list[which(my_list != 0)])

#length(carto.wb$adj)

#in the WinBUGS code
# Tau2 <- rep(0, n.adj/2) #the number of edges, or neighbours divided by 2
# for (i in length(Tau2)){
#   Tau2[i] ~ dgamma(1, 1.2) #or something like that, could also have hyperparameters and priors
# }

# # Precision of the conditional distribution of spatial effects
# for (j in 1:Ndiseases) {
#     for (i in 1:Nareas) {
#       prec.phi[i, j] <- sum(Tau2[my_list[[i]]])
#     }
# }
# 
# # Mean of the conditional distribution of spatial effects
#   for (j in 1:Ndiseases) {
#     mean.phi[1, j] <- inprod2(Tau2[my_list[[1]]],
#       phi.adj[index[1]:index[2], j])/sum(Tau2[my_list[[1]]])
#     for (i in 2:Nareas) {
#       mean.phi[i, j] <- inprod2(Tau2[my_list[[i]]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(Tau2[my_list[[1]]])
#     }
#   }

#Alternatively I make the list my_list outside the WinBUGS part and instead add indexes that
# correspond to a position in the Tau2 vector in the WinBUGS code. That should work, and to 
# find the taus for a specific region i i get the indexes from my_list as inputs to Tau2.
# They will also be in increasing numbering for each i, which aligns with the other vars.
```



```{r}
# Multivariate adaptive BYM model, WinBUGS code
NSRW1_model <- function() {
  # Likelihood
  for (i in 1:Nareas) {
    for (j in 1:Ndiseases) {
      O[i, j] ~ dpois(lambda[i, j])
      # Modeling of the mean for each census tract and disease
      log(lambda[i, j]) <- log(E[i, j]) + mu[j] + phi[i,j] + sd.theta[j] * theta[i, j]
      # SMR for each census tract and disease
      SMR[i, j] <- exp(mu[j] + phi[i, j] + sd.theta[j] * theta[i, j])
      # Prior distribution for spatial effects
      phi[i, j] ~ dnorm(mean.phi[i, j], prec.phi[i, j])
      # Prior distribution for non-spatial effects
      theta[i, j] ~ dnorm(0, 1)
    }
  }
  
  for (i in 1:n.adj) {
    for (j in 1:Ndiseases) {
      phi.adj[i, j] <- phi[adj[i], j]
    }
  }

  for (j in 1:Ndiseases) {
     prec.phi[1, j] <- sum(Tau2.tau.list[index[1]:index[2]])
     for (i in 2:Nareas) {
       prec.phi[i, j] <- sum(Tau2.tau.list[(index[i]+1):index[i+1]])
     }
  }
  for(i in 1:n.adj){ #to avoid nesting to many lists inside each other, causes crashes
    Tau2.tau.list[i]<-Tau2[tau.list[i]]
  }  
  

  # Mean of the conditional distribution of spatial effects
  for (j in 1:Ndiseases) {
      mean.phi[1, j] <- inprod2(Tau2.tau.list[index[1]:index[2]],
      phi.adj[index[1]:index[2], j])/sum(Tau2.tau.list[index[1]:index[2]])
    for (i in 2:Nareas) {
      mean.phi[i, j] <- inprod2(Tau2.tau.list[(index[i]+1):index[i+1]], phi.adj[(index[i] + 1):index[i + 1], j])/sum(Tau2.tau.list[(index[i]+1):index[i+1]])
    }
    # Sum-to-zero restriction for spatial effects
    ceros[j] <- 0
    ceros[j] ~ dnorm(sum.phi[j], 10)
    sum.phi[j] <- sum(phi[, j])
  }
  #Added stuff for the precisions Tau for all the pairs of neighbors
  #Tau2 <- rep(1, n.adj/2) #the number of edges, or neighbours divided by 2
  for (t in 1:111){
    Tau2[t] ~ dgamma(alpha, alpha) %_% I(0.001, ) #or something like that, could also have hyperparameters and priors
  }
  # Prior distributions for 
  alpha <- pow(sd.alpha, -2)
  sd.alpha ~ dunif(0, 5)
  
  # Other prior distributions
  for (j in 1:Ndiseases) {
    sd.phi[j] ~ dunif(0, 5)
    sd.theta[j] ~ dunif(0, 5)
    mu[j] ~ dflat()
  }
}
```

```{r}
runtime_NSRW1 <- rep(0, 4)

my_list[210:213]
# 10 causes

t0 <- Sys.time()

causes.id <- causes10
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index, 
             tau.list = my_list)
# Initial values
initials_NSRW1 <- function() {
  list(mu = rnorm(data$Ndiseases, 0, 1), sd.phi = runif(data$Ndiseases,0, 1), 
       sd.theta = runif(data$Ndiseases, 0, 1), 
       phi = matrix(rnorm(data$Nareas * data$Ndiseases), nrow = data$Nareas, 
              ncol = data$Ndiseases),
       theta = matrix(rnorm(data$Nareas * data$Ndiseases),
              nrow = data$Nareas, ncol = data$Ndiseases), 
       Tau2 = runif(data$n.adj/2, 0.5, 3))
}

# Variables to retrieve
param_NSRW1 <- c("mu", "lambda", "sd.phi", "phi", "sd.theta", "theta","SMR", "Tau2", "sd.alpha", "alpha")
# Calls to WinBUGS
results.NSRW1.10 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = T)
t1 <- Sys.time()
runtime_NSRW1[1] <- t1 - t0

# 20 causes

t0 <- Sys.time()

causes.id <- causes20
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.NSRW1.20 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 10000, n.burnin = 5000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[2] <- t1 - t0

# 50 causes

t0 <- Sys.time()

causes.id <- causes50
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.NSRW1.50 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 25000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[3] <- t1 - t0

# All 86 causes

t0 <- Sys.time()

causes.id <- causes86
# Data
data <- list(O = ObservedCases, E = ExpectedCases,
             Nareas = nrow(ObservedCases), Ndiseases = length(causes.id),
             n.adj = length(carto.wb$adj), adj = carto.wb$adj, index = index)

# Calls to WinBUGS
results.NSRW1.86 <- pbugs(data = data, inits = initials_NSRW1,
                              parameters.to.save = param_NSRW1, model = NSRW1_model,
                              n.iter = 30000, n.burnin = 10000, n.chains = 3, DIC = F,
                              debug = F)
t1 <- Sys.time()
runtime_NSRW1[4] <- t1 - t0


# Comparing runtimes

runtime_NSRW1

result_list_NSRW1 <- list(results.NSRW1.10, results.NSRW1.20, results.NSRW1.50, 
                    results.NSRW1.86)
saveRDS(result_list_NSRW1, file = "Results//result_list_NSRW1.rds")
```


NB:
Was the national mortality data subtracted by the provinces we removed when calculating the expected cases?


